#! /bin/sh
# Generated from local.at by GNU Autoconf 2.68.
#
# Copyright (C) 2009, 2010 Free Software Foundation, Inc.
#
# This test suite is free software; the Free Software Foundation gives
# unlimited permission to copy, distribute and modify it.
## -------------------- ##
## M4sh Initialization. ##
## -------------------- ##

# Be more Bourne compatible
DUALCASE=1; export DUALCASE # for MKS sh
if test -n "${ZSH_VERSION+set}" && (emulate sh) >/dev/null 2>&1; then :
  emulate sh
  NULLCMD=:
  # Pre-4.2 versions of Zsh do word splitting on ${1+"$@"}, which
  # is contrary to our usage.  Disable this feature.
  alias -g '${1+"$@"}'='"$@"'
  setopt NO_GLOB_SUBST
else
  case `(set -o) 2>/dev/null` in #(
  *posix*) :
    set -o posix ;; #(
  *) :
     ;;
esac
fi


as_nl='
'
export as_nl
# Printing a long string crashes Solaris 7 /usr/bin/printf.
as_echo='\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'
as_echo=$as_echo$as_echo$as_echo$as_echo$as_echo
as_echo=$as_echo$as_echo$as_echo$as_echo$as_echo$as_echo
# Prefer a ksh shell builtin over an external printf program on Solaris,
# but without wasting forks for bash or zsh.
if test -z "$BASH_VERSION$ZSH_VERSION" \
    && (test "X`print -r -- $as_echo`" = "X$as_echo") 2>/dev/null; then
  as_echo='print -r --'
  as_echo_n='print -rn --'
elif (test "X`printf %s $as_echo`" = "X$as_echo") 2>/dev/null; then
  as_echo='printf %s\n'
  as_echo_n='printf %s'
else
  if test "X`(/usr/ucb/echo -n -n $as_echo) 2>/dev/null`" = "X-n $as_echo"; then
    as_echo_body='eval /usr/ucb/echo -n "$1$as_nl"'
    as_echo_n='/usr/ucb/echo -n'
  else
    as_echo_body='eval expr "X$1" : "X\\(.*\\)"'
    as_echo_n_body='eval
      arg=$1;
      case $arg in #(
      *"$as_nl"*)
	expr "X$arg" : "X\\(.*\\)$as_nl";
	arg=`expr "X$arg" : ".*$as_nl\\(.*\\)"`;;
      esac;
      expr "X$arg" : "X\\(.*\\)" | tr -d "$as_nl"
    '
    export as_echo_n_body
    as_echo_n='sh -c $as_echo_n_body as_echo'
  fi
  export as_echo_body
  as_echo='sh -c $as_echo_body as_echo'
fi

# The user is always right.
if test "${PATH_SEPARATOR+set}" != set; then
  PATH_SEPARATOR=:
  (PATH='/bin;/bin'; FPATH=$PATH; sh -c :) >/dev/null 2>&1 && {
    (PATH='/bin:/bin'; FPATH=$PATH; sh -c :) >/dev/null 2>&1 ||
      PATH_SEPARATOR=';'
  }
fi


# IFS
# We need space, tab and new line, in precisely that order.  Quoting is
# there to prevent editors from complaining about space-tab.
# (If _AS_PATH_WALK were called with IFS unset, it would disable word
# splitting by setting IFS to empty value.)
IFS=" ""	$as_nl"

# Find who we are.  Look in the path if we contain no directory separator.
as_myself=
case $0 in #((
  *[\\/]* ) as_myself=$0 ;;
  *) as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
for as_dir in $PATH
do
  IFS=$as_save_IFS
  test -z "$as_dir" && as_dir=.
    test -r "$as_dir/$0" && as_myself=$as_dir/$0 && break
  done
IFS=$as_save_IFS

     ;;
esac
# We did not find ourselves, most probably we were run as `sh COMMAND'
# in which case we are not to be found in the path.
if test "x$as_myself" = x; then
  as_myself=$0
fi
if test ! -f "$as_myself"; then
  $as_echo "$as_myself: error: cannot find myself; rerun with an absolute file name" >&2
  exit 1
fi

# Unset variables that we do not need and which cause bugs (e.g. in
# pre-3.0 UWIN ksh).  But do not cause bugs in bash 2.01; the "|| exit 1"
# suppresses any "Segmentation fault" message there.  '((' could
# trigger a bug in pdksh 5.2.14.
for as_var in BASH_ENV ENV MAIL MAILPATH
do eval test x\${$as_var+set} = xset \
  && ( (unset $as_var) || exit 1) >/dev/null 2>&1 && unset $as_var || :
done
PS1='$ '
PS2='> '
PS4='+ '

# NLS nuisances.
LC_ALL=C
export LC_ALL
LANGUAGE=C
export LANGUAGE

# CDPATH.
(unset CDPATH) >/dev/null 2>&1 && unset CDPATH

if test "x$CONFIG_SHELL" = x; then
  as_bourne_compatible="if test -n \"\${ZSH_VERSION+set}\" && (emulate sh) >/dev/null 2>&1; then :
  emulate sh
  NULLCMD=:
  # Pre-4.2 versions of Zsh do word splitting on \${1+\"\$@\"}, which
  # is contrary to our usage.  Disable this feature.
  alias -g '\${1+\"\$@\"}'='\"\$@\"'
  setopt NO_GLOB_SUBST
else
  case \`(set -o) 2>/dev/null\` in #(
  *posix*) :
    set -o posix ;; #(
  *) :
     ;;
esac
fi
"
  as_required="as_fn_return () { (exit \$1); }
as_fn_success () { as_fn_return 0; }
as_fn_failure () { as_fn_return 1; }
as_fn_ret_success () { return 0; }
as_fn_ret_failure () { return 1; }

exitcode=0
as_fn_success || { exitcode=1; echo as_fn_success failed.; }
as_fn_failure && { exitcode=1; echo as_fn_failure succeeded.; }
as_fn_ret_success || { exitcode=1; echo as_fn_ret_success failed.; }
as_fn_ret_failure && { exitcode=1; echo as_fn_ret_failure succeeded.; }
if ( set x; as_fn_ret_success y && test x = \"\$1\" ); then :

else
  exitcode=1; echo positional parameters were not saved.
fi
test x\$exitcode = x0 || exit 1"
  as_suggested="  as_lineno_1=";as_suggested=$as_suggested$LINENO;as_suggested=$as_suggested" as_lineno_1a=\$LINENO
  as_lineno_2=";as_suggested=$as_suggested$LINENO;as_suggested=$as_suggested" as_lineno_2a=\$LINENO
  eval 'test \"x\$as_lineno_1'\$as_run'\" != \"x\$as_lineno_2'\$as_run'\" &&
  test \"x\`expr \$as_lineno_1'\$as_run' + 1\`\" = \"x\$as_lineno_2'\$as_run'\"' || exit 1
test \$(( 1 + 1 )) = 2 || exit 1"
  if (eval "$as_required") 2>/dev/null; then :
  as_have_required=yes
else
  as_have_required=no
fi
  if test x$as_have_required = xyes && (eval "$as_suggested") 2>/dev/null; then :

else
  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
as_found=false
for as_dir in /bin$PATH_SEPARATOR/usr/bin$PATH_SEPARATOR$PATH
do
  IFS=$as_save_IFS
  test -z "$as_dir" && as_dir=.
  as_found=:
  case $as_dir in #(
	 /*)
	   for as_base in sh bash ksh sh5; do
	     # Try only shells that exist, to save several forks.
	     as_shell=$as_dir/$as_base
	     if { test -f "$as_shell" || test -f "$as_shell.exe"; } &&
		    { $as_echo "$as_bourne_compatible""$as_required" | as_run=a "$as_shell"; } 2>/dev/null; then :
  CONFIG_SHELL=$as_shell as_have_required=yes
		   if { $as_echo "$as_bourne_compatible""$as_suggested" | as_run=a "$as_shell"; } 2>/dev/null; then :
  break 2
fi
fi
	   done;;
       esac
  as_found=false
done
$as_found || { if { test -f "$SHELL" || test -f "$SHELL.exe"; } &&
	      { $as_echo "$as_bourne_compatible""$as_required" | as_run=a "$SHELL"; } 2>/dev/null; then :
  CONFIG_SHELL=$SHELL as_have_required=yes
fi; }
IFS=$as_save_IFS


      if test "x$CONFIG_SHELL" != x; then :
  # We cannot yet assume a decent shell, so we have to provide a
	# neutralization value for shells without unset; and this also
	# works around shells that cannot unset nonexistent variables.
	# Preserve -v and -x to the replacement shell.
	BASH_ENV=/dev/null
	ENV=/dev/null
	(unset BASH_ENV) >/dev/null 2>&1 && unset BASH_ENV ENV
	export CONFIG_SHELL
	case $- in # ((((
	  *v*x* | *x*v* ) as_opts=-vx ;;
	  *v* ) as_opts=-v ;;
	  *x* ) as_opts=-x ;;
	  * ) as_opts= ;;
	esac
	exec "$CONFIG_SHELL" $as_opts "$as_myself" ${1+"$@"}
fi

    if test x$as_have_required = xno; then :
  $as_echo "$0: This script requires a shell more modern than all"
  $as_echo "$0: the shells that I found on your system."
  if test x${ZSH_VERSION+set} = xset ; then
    $as_echo "$0: In particular, zsh $ZSH_VERSION has bugs and should"
    $as_echo "$0: be upgraded to zsh 4.3.4 or later."
  else
    $as_echo "$0: Please tell bug-autoconf@gnu.org about your system,
$0: including any error possibly output before this
$0: message. Then install a modern shell, or manually run
$0: the script under such a shell if you do have one."
  fi
  exit 1
fi
fi
fi
SHELL=${CONFIG_SHELL-/bin/sh}
export SHELL
# Unset more variables known to interfere with behavior of common tools.
CLICOLOR_FORCE= GREP_OPTIONS=
unset CLICOLOR_FORCE GREP_OPTIONS

## --------------------- ##
## M4sh Shell Functions. ##
## --------------------- ##
# as_fn_unset VAR
# ---------------
# Portably unset VAR.
as_fn_unset ()
{
  { eval $1=; unset $1;}
}
as_unset=as_fn_unset

# as_fn_set_status STATUS
# -----------------------
# Set $? to STATUS, without forking.
as_fn_set_status ()
{
  return $1
} # as_fn_set_status

# as_fn_exit STATUS
# -----------------
# Exit the shell with STATUS, even in a "trap 0" or "set -e" context.
as_fn_exit ()
{
  set +e
  as_fn_set_status $1
  exit $1
} # as_fn_exit

# as_fn_mkdir_p
# -------------
# Create "$as_dir" as a directory, including parents if necessary.
as_fn_mkdir_p ()
{

  case $as_dir in #(
  -*) as_dir=./$as_dir;;
  esac
  test -d "$as_dir" || eval $as_mkdir_p || {
    as_dirs=
    while :; do
      case $as_dir in #(
      *\'*) as_qdir=`$as_echo "$as_dir" | sed "s/'/'\\\\\\\\''/g"`;; #'(
      *) as_qdir=$as_dir;;
      esac
      as_dirs="'$as_qdir' $as_dirs"
      as_dir=`$as_dirname -- "$as_dir" ||
$as_expr X"$as_dir" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
	 X"$as_dir" : 'X\(//\)[^/]' \| \
	 X"$as_dir" : 'X\(//\)$' \| \
	 X"$as_dir" : 'X\(/\)' \| . 2>/dev/null ||
$as_echo X"$as_dir" |
    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
	    s//\1/
	    q
	  }
	  /^X\(\/\/\)[^/].*/{
	    s//\1/
	    q
	  }
	  /^X\(\/\/\)$/{
	    s//\1/
	    q
	  }
	  /^X\(\/\).*/{
	    s//\1/
	    q
	  }
	  s/.*/./; q'`
      test -d "$as_dir" && break
    done
    test -z "$as_dirs" || eval "mkdir $as_dirs"
  } || test -d "$as_dir" || as_fn_error $? "cannot create directory $as_dir"


} # as_fn_mkdir_p
# as_fn_append VAR VALUE
# ----------------------
# Append the text in VALUE to the end of the definition contained in VAR. Take
# advantage of any shell optimizations that allow amortized linear growth over
# repeated appends, instead of the typical quadratic growth present in naive
# implementations.
if (eval "as_var=1; as_var+=2; test x\$as_var = x12") 2>/dev/null; then :
  eval 'as_fn_append ()
  {
    eval $1+=\$2
  }'
else
  as_fn_append ()
  {
    eval $1=\$$1\$2
  }
fi # as_fn_append

# as_fn_arith ARG...
# ------------------
# Perform arithmetic evaluation on the ARGs, and store the result in the
# global $as_val. Take advantage of shells that can avoid forks. The arguments
# must be portable across $(()) and expr.
if (eval "test \$(( 1 + 1 )) = 2") 2>/dev/null; then :
  eval 'as_fn_arith ()
  {
    as_val=$(( $* ))
  }'
else
  as_fn_arith ()
  {
    as_val=`expr "$@" || test $? -eq 1`
  }
fi # as_fn_arith


# as_fn_error STATUS ERROR [LINENO LOG_FD]
# ----------------------------------------
# Output "`basename $0`: error: ERROR" to stderr. If LINENO and LOG_FD are
# provided, also output the error to LOG_FD, referencing LINENO. Then exit the
# script with STATUS, using 1 if that was 0.
as_fn_error ()
{
  as_status=$1; test $as_status -eq 0 && as_status=1
  if test "$4"; then
    as_lineno=${as_lineno-"$3"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
    $as_echo "$as_me:${as_lineno-$LINENO}: error: $2" >&$4
  fi
  $as_echo "$as_me: error: $2" >&2
  as_fn_exit $as_status
} # as_fn_error

if expr a : '\(a\)' >/dev/null 2>&1 &&
   test "X`expr 00001 : '.*\(...\)'`" = X001; then
  as_expr=expr
else
  as_expr=false
fi

if (basename -- /) >/dev/null 2>&1 && test "X`basename -- / 2>&1`" = "X/"; then
  as_basename=basename
else
  as_basename=false
fi

as_me=`$as_basename -- "$0" ||
$as_expr X/"$0" : '.*/\([^/][^/]*\)/*$' \| \
	 X"$0" : 'X\(//\)$' \| \
	 X"$0" : 'X\(/\)' \| . 2>/dev/null ||
$as_echo X/"$0" |
    sed '/^.*\/\([^/][^/]*\)\/*$/{
	    s//\1/
	    q
	  }
	  /^X\/\(\/\/\)$/{
	    s//\1/
	    q
	  }
	  /^X\/\(\/\).*/{
	    s//\1/
	    q
	  }
	  s/.*/./; q'`

if (as_dir=`dirname -- /` && test "X$as_dir" = X/) >/dev/null 2>&1; then
  as_dirname=dirname
else
  as_dirname=false
fi

# Avoid depending upon Character Ranges.
as_cr_letters='abcdefghijklmnopqrstuvwxyz'
as_cr_LETTERS='ABCDEFGHIJKLMNOPQRSTUVWXYZ'
as_cr_Letters=$as_cr_letters$as_cr_LETTERS
as_cr_digits='0123456789'
as_cr_alnum=$as_cr_Letters$as_cr_digits


  as_lineno_1=$LINENO as_lineno_1a=$LINENO
  as_lineno_2=$LINENO as_lineno_2a=$LINENO
  eval 'test "x$as_lineno_1'$as_run'" != "x$as_lineno_2'$as_run'" &&
  test "x`expr $as_lineno_1'$as_run' + 1`" = "x$as_lineno_2'$as_run'"' || {
  # Blame Lee E. McMahon (1931-1989) for sed's syntax.  :-)
  sed -n '
    p
    /[$]LINENO/=
  ' <$as_myself |
    sed '
      s/[$]LINENO.*/&-/
      t lineno
      b
      :lineno
      N
      :loop
      s/[$]LINENO\([^'$as_cr_alnum'_].*\n\)\(.*\)/\2\1\2/
      t loop
      s/-\n.*//
    ' >$as_me.lineno &&
  chmod +x "$as_me.lineno" ||
    { $as_echo "$as_me: error: cannot create $as_me.lineno; rerun with a POSIX shell" >&2; as_fn_exit 1; }

  # Don't try to exec as it changes $[0], causing all sort of problems
  # (the dirname of $[0] is not the place where we might find the
  # original and so on.  Autoconf is especially sensitive to this).
  . "./$as_me.lineno"
  # Exit status is that of the last command.
  exit
}

ECHO_C= ECHO_N= ECHO_T=
case `echo -n x` in #(((((
-n*)
  case `echo 'xy\c'` in
  *c*) ECHO_T='	';;	# ECHO_T is single tab character.
  xy)  ECHO_C='\c';;
  *)   echo `echo ksh88 bug on AIX 6.1` > /dev/null
       ECHO_T='	';;
  esac;;
*)
  ECHO_N='-n';;
esac

rm -f conf$$ conf$$.exe conf$$.file
if test -d conf$$.dir; then
  rm -f conf$$.dir/conf$$.file
else
  rm -f conf$$.dir
  mkdir conf$$.dir 2>/dev/null
fi
if (echo >conf$$.file) 2>/dev/null; then
  if ln -s conf$$.file conf$$ 2>/dev/null; then
    as_ln_s='ln -s'
    # ... but there are two gotchas:
    # 1) On MSYS, both `ln -s file dir' and `ln file dir' fail.
    # 2) DJGPP < 2.04 has no symlinks; `ln -s' creates a wrapper executable.
    # In both cases, we have to default to `cp -p'.
    ln -s conf$$.file conf$$.dir 2>/dev/null && test ! -f conf$$.exe ||
      as_ln_s='cp -p'
  elif ln conf$$.file conf$$ 2>/dev/null; then
    as_ln_s=ln
  else
    as_ln_s='cp -p'
  fi
else
  as_ln_s='cp -p'
fi
rm -f conf$$ conf$$.exe conf$$.dir/conf$$.file conf$$.file
rmdir conf$$.dir 2>/dev/null

if mkdir -p . 2>/dev/null; then
  as_mkdir_p='mkdir -p "$as_dir"'
else
  test -d ./-p && rmdir ./-p
  as_mkdir_p=false
fi

if test -x / >/dev/null 2>&1; then
  as_test_x='test -x'
else
  if ls -dL / >/dev/null 2>&1; then
    as_ls_L_option=L
  else
    as_ls_L_option=
  fi
  as_test_x='
    eval sh -c '\''
      if test -d "$1"; then
	test -d "$1/.";
      else
	case $1 in #(
	-*)set "./$1";;
	esac;
	case `ls -ld'$as_ls_L_option' "$1" 2>/dev/null` in #((
	???[sx]*):;;*)false;;esac;fi
    '\'' sh
  '
fi
as_executable_p=$as_test_x

# Sed expression to map a string onto a valid CPP name.
as_tr_cpp="eval sed 'y%*$as_cr_letters%P$as_cr_LETTERS%;s%[^_$as_cr_alnum]%_%g'"

# Sed expression to map a string onto a valid variable name.
as_tr_sh="eval sed 'y%*+%pp%;s%[^_$as_cr_alnum]%_%g'"





SHELL=${CONFIG_SHELL-/bin/sh}

# How were we run?
at_cli_args="$@"


# Not all shells have the 'times' builtin; the subshell is needed to make
# sure we discard the 'times: not found' message from the shell.
at_times_p=false
(times) >/dev/null 2>&1 && at_times_p=:

# CLI Arguments to pass to the debugging scripts.
at_debug_args=
# -e sets to true
at_errexit_p=false
# Shall we be verbose?  ':' means no, empty means yes.
at_verbose=:
at_quiet=
# Running several jobs in parallel, 0 means as many as test groups.
at_jobs=1
at_traceon=:
at_trace_echo=:
at_check_filter_trace=:

# Shall we keep the debug scripts?  Must be `:' when the suite is
# run by a debug script, so that the script doesn't remove itself.
at_debug_p=false
# Display help message?
at_help_p=false
# Display the version message?
at_version_p=false
# List test groups?
at_list_p=false
# --clean
at_clean=false
# Test groups to run
at_groups=
# Whether to rerun failed tests.
at_recheck=
# Whether a write failure occurred
at_write_fail=0

# The directory we run the suite in.  Default to . if no -C option.
at_dir=`pwd`
# An absolute reference to this testsuite script.
case $as_myself in
  [\\/]* | ?:[\\/]* ) at_myself=$as_myself ;;
  * ) at_myself=$at_dir/$as_myself ;;
esac
# Whether -C is in effect.
at_change_dir=false

# Whether to enable colored test results.
at_color=no
# List of the tested programs.
at_tested=''
# As many question marks as there are digits in the last test group number.
# Used to normalize the test group numbers so that `ls' lists them in
# numerical order.
at_format='??'
# Description of all the test groups.
at_help_all="1;utils.at:9;btp_strcmp0;;
2;utils.at:29;btp_strchr_location;;
3;utils.at:65;btp_strstr_location;;
4;utils.at:105;btp_strspn_location;;
5;utils.at:138;btp_skip_char;;
6;utils.at:155;btp_skip_char_limited;;
7;utils.at:173;btp_parse_char_limited;;
8;utils.at:210;btp_skip_char_sequence;;
9;utils.at:228;btp_skip_char_span;;
10;utils.at:250;btp_skip_char_span_location;;
11;utils.at:284;btp_parse_char_span;;
12;utils.at:308;btp_parse_char_cspan;;
13;utils.at:332;btp_skip_string;;
14;utils.at:352;btp_parse_string;;
15;utils.at:372;btp_skip_unsigned_integer;;
16;utils.at:389;btp_parse_unsigned_integer;;
17;utils.at:408;btp_skip_hexadecimal_number;;
18;utils.at:425;btp_parse_hexadecimal_number;;
19;strbuf.at:9;btp_strbuf_append_char;;
20;strbuf.at:37;btp_strbuf_append_str;;
21;frame.at:9;btp_frame_dup;;
22;frame.at:64;btp_frame_parse_frame_start;;
23;frame.at:112;btp_frame_parseadd_operator;;
24;frame.at:156;btp_frame_parse_function_name;;
25;frame.at:218;btp_frame_skip_function_args;;
26;frame.at:262;btp_frame_parse_function_call;;
27;frame.at:367;btp_frame_parse_address_in_function;;
28;frame.at:423;btp_frame_parse_file_location;;
29;frame.at:485;btp_frame_parse_header;;
30;frame.at:576;btp_frame_parse;;
31;thread.at:8;btp_thread_remove_frame;;
32;thread.at:72;btp_thread_remove_frames_above;;
33;thread.at:137;btp_thread_remove_frames_below_n;;
34;thread.at:204;btp_thread_parse;;
35;thread.at:302;btp_thread_parse-locations;;
36;thread.at:371;btp_thread_skip_lwp;;
37;backtrace.at:8;btp_backtrace_remove_threads_except_one;;
38;backtrace.at:61;btp_backtrace_find_crash_thread;;
39;backtrace.at:93;btp_backtrace_limit_frame_depth;;
40;backtrace.at:130;btp_backtrace_quality_complex;;
41;normalize.at:44;btp_normalize_thread_removes_zeroes;;
42;normalize.at:88;btp_normalize_paired_unknown_function_names;;
43;metrics.at:43;metrics_all_one_thread_empty;;
44;metrics.at:62;metrics_all_both_threads_empty;;
45;metrics.at:81;metrics_all_both_starting_??_levendistance3_a;;
46;metrics.at:100;metrics_all_both_starting_??_levendistance3_b;;
47;metrics.at:119;metrics_levenshtein_random_??_levendistance0_a;;
48;metrics.at:136;metrics_levenshtein_random_??_levendistance0_b;;
49;metrics.at:153;metrics_levenshtein_random_??_distance1;;
50;metrics.at:170;metrics_levenshtein_random_??_distance2_a;;
51;metrics.at:187;metrics_levenshtein_random_??_distance2_b;;
52;metrics.at:204;metrics_levenshtein_random_??_distance2_c;;
53;metrics.at:221;metrics_levenshtein_trans_??_distance2_a;;
54;metrics.at:238;metrics_levenshtein_trans_??_distance2_b;;
55;metrics.at:255;metrics_levenshtein_swap_trans_distance2_a;;
56;metrics.at:269;metrics_levenshtein_swap_notrans_distance3_a;;
57;metrics.at:283;metrics_jaccard_random_??_distance0_a;;
58;metrics.at:300;metrics_jaccard_random_??_distance23_a;;
59;metrics.at:315;metrics_jaccard_random_??_distance35;;
60;metrics.at:330;distances_basic_properties;;
61;metrics.at:360;distances_threads_compare;;
62;cluster.at:3;btp_distances_cluster_objects;;
63;cluster.at:71;btp_dendrogram_cut;;
64;sharedlib.at:8;btp_sharedlib_parse;;
65;sharedlib.at:33;btp_sharedlib_count;;
66;sharedlib.at:55;btp_sharedlib_append;;
67;sharedlib.at:80;btp_sharedlib_find_address;;
"
# List of the all the test groups.
at_groups_all=`$as_echo "$at_help_all" | sed 's/;.*//'`

# at_fn_validate_ranges NAME...
# -----------------------------
# Validate and normalize the test group number contained in each variable
# NAME. Leading zeroes are treated as decimal.
at_fn_validate_ranges ()
{
  for at_grp
  do
    eval at_value=\$$at_grp
    if test $at_value -lt 1 || test $at_value -gt 67; then
      $as_echo "invalid test group: $at_value" >&2
      exit 1
    fi
    case $at_value in
      0*) # We want to treat leading 0 as decimal, like expr and test, but
	  # AS_VAR_ARITH treats it as octal if it uses $(( )).
	  # With XSI shells, ${at_value#${at_value%%[1-9]*}} avoids the
	  # expr fork, but it is not worth the effort to determine if the
	  # shell supports XSI when the user can just avoid leading 0.
	  eval $at_grp='`expr $at_value + 0`' ;;
    esac
  done
}

at_prev=
for at_option
do
  # If the previous option needs an argument, assign it.
  if test -n "$at_prev"; then
    at_option=$at_prev=$at_option
    at_prev=
  fi

  case $at_option in
  *=?*) at_optarg=`expr "X$at_option" : '[^=]*=\(.*\)'` ;;
  *)    at_optarg= ;;
  esac

  # Accept the important Cygnus configure options, so we can diagnose typos.

  case $at_option in
    --help | -h )
	at_help_p=:
	;;

    --list | -l )
	at_list_p=:
	;;

    --version | -V )
	at_version_p=:
	;;

    --clean | -c )
	at_clean=:
	;;

    --color )
	at_color=always
	;;
    --color=* )
	case $at_optarg in
	no | never | none) at_color=never ;;
	auto | tty | if-tty) at_color=auto ;;
	always | yes | force) at_color=always ;;
	*) at_optname=`echo " $at_option" | sed 's/^ //; s/=.*//'`
	   as_fn_error $? "unrecognized argument to $at_optname: $at_optarg" ;;
	esac
	;;

    --debug | -d )
	at_debug_p=:
	;;

    --errexit | -e )
	at_debug_p=:
	at_errexit_p=:
	;;

    --verbose | -v )
	at_verbose=; at_quiet=:
	;;

    --trace | -x )
	at_traceon='set -x'
	at_trace_echo=echo
	at_check_filter_trace=at_fn_filter_trace
	;;

    [0-9] | [0-9][0-9] | [0-9][0-9][0-9] | [0-9][0-9][0-9][0-9])
	at_fn_validate_ranges at_option
	as_fn_append at_groups "$at_option$as_nl"
	;;

    # Ranges
    [0-9]- | [0-9][0-9]- | [0-9][0-9][0-9]- | [0-9][0-9][0-9][0-9]-)
	at_range_start=`echo $at_option |tr -d X-`
	at_fn_validate_ranges at_range_start
	at_range=`$as_echo "$at_groups_all" | \
	  sed -ne '/^'$at_range_start'$/,$p'`
	as_fn_append at_groups "$at_range$as_nl"
	;;

    -[0-9] | -[0-9][0-9] | -[0-9][0-9][0-9] | -[0-9][0-9][0-9][0-9])
	at_range_end=`echo $at_option |tr -d X-`
	at_fn_validate_ranges at_range_end
	at_range=`$as_echo "$at_groups_all" | \
	  sed -ne '1,/^'$at_range_end'$/p'`
	as_fn_append at_groups "$at_range$as_nl"
	;;

    [0-9]-[0-9] | [0-9]-[0-9][0-9] | [0-9]-[0-9][0-9][0-9] | \
    [0-9]-[0-9][0-9][0-9][0-9] | [0-9][0-9]-[0-9][0-9] | \
    [0-9][0-9]-[0-9][0-9][0-9] | [0-9][0-9]-[0-9][0-9][0-9][0-9] | \
    [0-9][0-9][0-9]-[0-9][0-9][0-9] | \
    [0-9][0-9][0-9]-[0-9][0-9][0-9][0-9] | \
    [0-9][0-9][0-9][0-9]-[0-9][0-9][0-9][0-9] )
	at_range_start=`expr $at_option : '\(.*\)-'`
	at_range_end=`expr $at_option : '.*-\(.*\)'`
	if test $at_range_start -gt $at_range_end; then
	  at_tmp=$at_range_end
	  at_range_end=$at_range_start
	  at_range_start=$at_tmp
	fi
	at_fn_validate_ranges at_range_start at_range_end
	at_range=`$as_echo "$at_groups_all" | \
	  sed -ne '/^'$at_range_start'$/,/^'$at_range_end'$/p'`
	as_fn_append at_groups "$at_range$as_nl"
	;;

    # Directory selection.
    --directory | -C )
	at_prev=--directory
	;;
    --directory=* )
	at_change_dir=:
	at_dir=$at_optarg
	if test x- = "x$at_dir" ; then
	  at_dir=./-
	fi
	;;

    # Parallel execution.
    --jobs | -j )
	at_jobs=0
	;;
    --jobs=* | -j[0-9]* )
	if test -n "$at_optarg"; then
	  at_jobs=$at_optarg
	else
	  at_jobs=`expr X$at_option : 'X-j\(.*\)'`
	fi
	case $at_jobs in *[!0-9]*)
	  at_optname=`echo " $at_option" | sed 's/^ //; s/[0-9=].*//'`
	  as_fn_error $? "non-numeric argument to $at_optname: $at_jobs" ;;
	esac
	;;

    # Keywords.
    --keywords | -k )
	at_prev=--keywords
	;;
    --keywords=* )
	at_groups_selected=$at_help_all
	at_save_IFS=$IFS
	IFS=,
	set X $at_optarg
	shift
	IFS=$at_save_IFS
	for at_keyword
	do
	  at_invert=
	  case $at_keyword in
	  '!'*)
	    at_invert="-v"
	    at_keyword=`expr "X$at_keyword" : 'X!\(.*\)'`
	    ;;
	  esac
	  # It is on purpose that we match the test group titles too.
	  at_groups_selected=`$as_echo "$at_groups_selected" |
	      grep -i $at_invert "^[1-9][^;]*;.*[; ]$at_keyword[ ;]"`
	done
	# Smash the keywords.
	at_groups_selected=`$as_echo "$at_groups_selected" | sed 's/;.*//'`
	as_fn_append at_groups "$at_groups_selected$as_nl"
	;;
    --recheck)
	at_recheck=:
	;;

    *=*)
	at_envvar=`expr "x$at_option" : 'x\([^=]*\)='`
	# Reject names that are not valid shell variable names.
	case $at_envvar in
	  '' | [0-9]* | *[!_$as_cr_alnum]* )
	    as_fn_error $? "invalid variable name: \`$at_envvar'" ;;
	esac
	at_value=`$as_echo "$at_optarg" | sed "s/'/'\\\\\\\\''/g"`
	# Export now, but save eval for later and for debug scripts.
	export $at_envvar
	as_fn_append at_debug_args " $at_envvar='$at_value'"
	;;

     *) $as_echo "$as_me: invalid option: $at_option" >&2
	$as_echo "Try \`$0 --help' for more information." >&2
	exit 1
	;;
  esac
done

# Verify our last option didn't require an argument
if test -n "$at_prev"; then :
  as_fn_error $? "\`$at_prev' requires an argument"
fi

# The file containing the suite.
at_suite_log=$at_dir/$as_me.log

# Selected test groups.
if test -z "$at_groups$at_recheck"; then
  at_groups=$at_groups_all
else
  if test -n "$at_recheck" && test -r "$at_suite_log"; then
    at_oldfails=`sed -n '
      /^Failed tests:$/,/^Skipped tests:$/{
	s/^[ ]*\([1-9][0-9]*\):.*/\1/p
      }
      /^Unexpected passes:$/,/^## Detailed failed tests/{
	s/^[ ]*\([1-9][0-9]*\):.*/\1/p
      }
      /^## Detailed failed tests/q
      ' "$at_suite_log"`
    as_fn_append at_groups "$at_oldfails$as_nl"
  fi
  # Sort the tests, removing duplicates.
  at_groups=`$as_echo "$at_groups" | sort -nu | sed '/^$/d'`
fi

if test x"$at_color" = xalways \
   || { test x"$at_color" = xauto && test -t 1; }; then
  at_red=`printf '\033[0;31m'`
  at_grn=`printf '\033[0;32m'`
  at_lgn=`printf '\033[1;32m'`
  at_blu=`printf '\033[1;34m'`
  at_std=`printf '\033[m'`
else
  at_red= at_grn= at_lgn= at_blu= at_std=
fi

# Help message.
if $at_help_p; then
  cat <<_ATEOF || at_write_fail=1
Usage: $0 [OPTION]... [VARIABLE=VALUE]... [TESTS]

Run all the tests, or the selected TESTS, given by numeric ranges, and
save a detailed log file.  Upon failure, create debugging scripts.

Do not change environment variables directly.  Instead, set them via
command line arguments.  Set \`AUTOTEST_PATH' to select the executables
to exercise.  Each relative directory is expanded as build and source
directories relative to the top level of this distribution.
E.g., from within the build directory /tmp/foo-1.0, invoking this:

  $ $0 AUTOTEST_PATH=bin

is equivalent to the following, assuming the source directory is /src/foo-1.0:

  PATH=/tmp/foo-1.0/bin:/src/foo-1.0/bin:\$PATH $0
_ATEOF
cat <<_ATEOF || at_write_fail=1

Operation modes:
  -h, --help     print the help message, then exit
  -V, --version  print version number, then exit
  -c, --clean    remove all the files this test suite might create and exit
  -l, --list     describes all the tests, or the selected TESTS
_ATEOF
cat <<_ATEOF || at_write_fail=1

Execution tuning:
  -C, --directory=DIR
                 change to directory DIR before starting
      --color[=never|auto|always]
                 enable colored test results on terminal, or always
  -j, --jobs[=N]
                 Allow N jobs at once; infinite jobs with no arg (default 1)
  -k, --keywords=KEYWORDS
                 select the tests matching all the comma-separated KEYWORDS
                 multiple \`-k' accumulate; prefixed \`!' negates a KEYWORD
      --recheck  select all tests that failed or passed unexpectedly last time
  -e, --errexit  abort as soon as a test fails; implies --debug
  -v, --verbose  force more detailed output
                 default for debugging scripts
  -d, --debug    inhibit clean up and top-level logging
                 default for debugging scripts
  -x, --trace    enable tests shell tracing
_ATEOF
cat <<_ATEOF || at_write_fail=1

Report bugs to <kklic@redhat.com>.
_ATEOF
  exit $at_write_fail
fi

# List of tests.
if $at_list_p; then
  cat <<_ATEOF || at_write_fail=1
btparser 0.17 test suite test groups:

 NUM: FILE-NAME:LINE     TEST-GROUP-NAME
      KEYWORDS

_ATEOF
  # Pass an empty line as separator between selected groups and help.
  $as_echo "$at_groups$as_nl$as_nl$at_help_all" |
    awk 'NF == 1 && FS != ";" {
	   selected[$ 1] = 1
	   next
	 }
	 /^$/ { FS = ";" }
	 NF > 0 {
	   if (selected[$ 1]) {
	     printf " %3d: %-18s %s\n", $ 1, $ 2, $ 3
	     if ($ 4) {
	       lmax = 79
	       indent = "     "
	       line = indent
	       len = length (line)
	       n = split ($ 4, a, " ")
	       for (i = 1; i <= n; i++) {
		 l = length (a[i]) + 1
		 if (i > 1 && len + l > lmax) {
		   print line
		   line = indent " " a[i]
		   len = length (line)
		 } else {
		   line = line " " a[i]
		   len += l
		 }
	       }
	       if (n)
		 print line
	     }
	   }
	 }' || at_write_fail=1
  exit $at_write_fail
fi
if $at_version_p; then
  $as_echo "$as_me (btparser 0.17)" &&
  cat <<\_ATEOF || at_write_fail=1

Copyright (C) 2010 Free Software Foundation, Inc.
This test suite is free software; the Free Software Foundation gives
unlimited permission to copy, distribute and modify it.
_ATEOF
  exit $at_write_fail
fi

# Should we print banners?  Yes if more than one test is run.
case $at_groups in #(
  *$as_nl* )
      at_print_banners=: ;; #(
  * ) at_print_banners=false ;;
esac
# Text for banner N, set to a single space once printed.
# Banner 1. utils.at:3
# Category starts at test group 1.
at_banner_text_1="Utils"
# Banner 2. strbuf.at:3
# Category starts at test group 19.
at_banner_text_2="strbuf"
# Banner 3. frame.at:3
# Category starts at test group 21.
at_banner_text_3="Frames"
# Banner 4. thread.at:3
# Category starts at test group 31.
at_banner_text_4="Threads"
# Banner 5. backtrace.at:3
# Category starts at test group 37.
at_banner_text_5="Backtraces"
# Banner 6. normalize.at:3
# Category starts at test group 41.
at_banner_text_6="Normalization"
# Banner 7. metrics.at:1
# Category starts at test group 43.
at_banner_text_7="Metrics"
# Banner 8. cluster.at:1
# Category starts at test group 62.
at_banner_text_8="Cluster"
# Banner 9. sharedlib.at:3
# Category starts at test group 64.
at_banner_text_9="sharedlib"

# Take any -C into account.
if $at_change_dir ; then
  test x != "x$at_dir" && cd "$at_dir" \
    || as_fn_error $? "unable to change directory"
  at_dir=`pwd`
fi

# Load the config files for any default variable assignments.
for at_file in atconfig atlocal
do
  test -r $at_file || continue
  . ./$at_file || as_fn_error $? "invalid content: $at_file"
done

# Autoconf <=2.59b set at_top_builddir instead of at_top_build_prefix:
: "${at_top_build_prefix=$at_top_builddir}"

# Perform any assignments requested during argument parsing.
eval "$at_debug_args"

# atconfig delivers names relative to the directory the test suite is
# in, but the groups themselves are run in testsuite-dir/group-dir.
if test -n "$at_top_srcdir"; then
  builddir=../..
  for at_dir_var in srcdir top_srcdir top_build_prefix
  do
    eval at_val=\$at_$at_dir_var
    case $at_val in
      [\\/$]* | ?:[\\/]* ) at_prefix= ;;
      *) at_prefix=../../ ;;
    esac
    eval "$at_dir_var=\$at_prefix\$at_val"
  done
fi

## -------------------- ##
## Directory structure. ##
## -------------------- ##

# This is the set of directories and files used by this script
# (non-literals are capitalized):
#
# TESTSUITE         - the testsuite
# TESTSUITE.log     - summarizes the complete testsuite run
# TESTSUITE.dir/    - created during a run, remains after -d or failed test
# + at-groups/      - during a run: status of all groups in run
# | + NNN/          - during a run: meta-data about test group NNN
# | | + check-line  - location (source file and line) of current AT_CHECK
# | | + status      - exit status of current AT_CHECK
# | | + stdout      - stdout of current AT_CHECK
# | | + stder1      - stderr, including trace
# | | + stderr      - stderr, with trace filtered out
# | | + test-source - portion of testsuite that defines group
# | | + times       - timestamps for computing duration
# | | + pass        - created if group passed
# | | + xpass       - created if group xpassed
# | | + fail        - created if group failed
# | | + xfail       - created if group xfailed
# | | + skip        - created if group skipped
# + at-stop         - during a run: end the run if this file exists
# + at-source-lines - during a run: cache of TESTSUITE line numbers for extraction
# + 0..NNN/         - created for each group NNN, remains after -d or failed test
# | + TESTSUITE.log - summarizes the group results
# | + ...           - files created during the group

# The directory the whole suite works in.
# Should be absolute to let the user `cd' at will.
at_suite_dir=$at_dir/$as_me.dir
# The file containing the suite ($at_dir might have changed since earlier).
at_suite_log=$at_dir/$as_me.log
# The directory containing helper files per test group.
at_helper_dir=$at_suite_dir/at-groups
# Stop file: if it exists, do not start new jobs.
at_stop_file=$at_suite_dir/at-stop
# The fifo used for the job dispatcher.
at_job_fifo=$at_suite_dir/at-job-fifo

if $at_clean; then
  test -d "$at_suite_dir" &&
    find "$at_suite_dir" -type d ! -perm -700 -exec chmod u+rwx \{\} \;
  rm -f -r "$at_suite_dir" "$at_suite_log"
  exit $?
fi

# Don't take risks: use only absolute directories in PATH.
#
# For stand-alone test suites (ie. atconfig was not found),
# AUTOTEST_PATH is relative to `.'.
#
# For embedded test suites, AUTOTEST_PATH is relative to the top level
# of the package.  Then expand it into build/src parts, since users
# may create executables in both places.
AUTOTEST_PATH=`$as_echo "$AUTOTEST_PATH" | sed "s|:|$PATH_SEPARATOR|g"`
at_path=
as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
for as_dir in $AUTOTEST_PATH $PATH
do
  IFS=$as_save_IFS
  test -z "$as_dir" && as_dir=.
    test -n "$at_path" && as_fn_append at_path $PATH_SEPARATOR
case $as_dir in
  [\\/]* | ?:[\\/]* )
    as_fn_append at_path "$as_dir"
    ;;
  * )
    if test -z "$at_top_build_prefix"; then
      # Stand-alone test suite.
      as_fn_append at_path "$as_dir"
    else
      # Embedded test suite.
      as_fn_append at_path "$at_top_build_prefix$as_dir$PATH_SEPARATOR"
      as_fn_append at_path "$at_top_srcdir/$as_dir"
    fi
    ;;
esac
  done
IFS=$as_save_IFS


# Now build and simplify PATH.
#
# There might be directories that don't exist, but don't redirect
# builtins' (eg., cd) stderr directly: Ultrix's sh hates that.
at_new_path=
as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
for as_dir in $at_path
do
  IFS=$as_save_IFS
  test -z "$as_dir" && as_dir=.
    test -d "$as_dir" || continue
case $as_dir in
  [\\/]* | ?:[\\/]* ) ;;
  * ) as_dir=`(cd "$as_dir" && pwd) 2>/dev/null` ;;
esac
case $PATH_SEPARATOR$at_new_path$PATH_SEPARATOR in
  *$PATH_SEPARATOR$as_dir$PATH_SEPARATOR*) ;;
  $PATH_SEPARATOR$PATH_SEPARATOR) at_new_path=$as_dir ;;
  *) as_fn_append at_new_path "$PATH_SEPARATOR$as_dir" ;;
esac
  done
IFS=$as_save_IFS

PATH=$at_new_path
export PATH

# Setting up the FDs.



# 5 is the log file.  Not to be overwritten if `-d'.
if $at_debug_p; then
  at_suite_log=/dev/null
else
  : >"$at_suite_log"
fi
exec 5>>"$at_suite_log"

# Banners and logs.
$as_echo "## ------------------------- ##
## btparser 0.17 test suite. ##
## ------------------------- ##"
{
  $as_echo "## ------------------------- ##
## btparser 0.17 test suite. ##
## ------------------------- ##"
  echo

  $as_echo "$as_me: command line was:"
  $as_echo "  \$ $0 $at_cli_args"
  echo

  # If ChangeLog exists, list a few lines in case it might help determining
  # the exact version.
  if test -n "$at_top_srcdir" && test -f "$at_top_srcdir/ChangeLog"; then
    $as_echo "## ---------- ##
## ChangeLog. ##
## ---------- ##"
    echo
    sed 's/^/| /;10q' "$at_top_srcdir/ChangeLog"
    echo
  fi

  {
cat <<_ASUNAME
## --------- ##
## Platform. ##
## --------- ##

hostname = `(hostname || uname -n) 2>/dev/null | sed 1q`
uname -m = `(uname -m) 2>/dev/null || echo unknown`
uname -r = `(uname -r) 2>/dev/null || echo unknown`
uname -s = `(uname -s) 2>/dev/null || echo unknown`
uname -v = `(uname -v) 2>/dev/null || echo unknown`

/usr/bin/uname -p = `(/usr/bin/uname -p) 2>/dev/null || echo unknown`
/bin/uname -X     = `(/bin/uname -X) 2>/dev/null     || echo unknown`

/bin/arch              = `(/bin/arch) 2>/dev/null              || echo unknown`
/usr/bin/arch -k       = `(/usr/bin/arch -k) 2>/dev/null       || echo unknown`
/usr/convex/getsysinfo = `(/usr/convex/getsysinfo) 2>/dev/null || echo unknown`
/usr/bin/hostinfo      = `(/usr/bin/hostinfo) 2>/dev/null      || echo unknown`
/bin/machine           = `(/bin/machine) 2>/dev/null           || echo unknown`
/usr/bin/oslevel       = `(/usr/bin/oslevel) 2>/dev/null       || echo unknown`
/bin/universe          = `(/bin/universe) 2>/dev/null          || echo unknown`

_ASUNAME

as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
for as_dir in $PATH
do
  IFS=$as_save_IFS
  test -z "$as_dir" && as_dir=.
    $as_echo "PATH: $as_dir"
  done
IFS=$as_save_IFS

}
  echo

  # Contents of the config files.
  for at_file in atconfig atlocal
  do
    test -r $at_file || continue
    $as_echo "$as_me: $at_file:"
    sed 's/^/| /' $at_file
    echo
  done
} >&5


## ------------------------- ##
## Autotest shell functions. ##
## ------------------------- ##

# at_fn_banner NUMBER
# -------------------
# Output banner NUMBER, provided the testsuite is running multiple groups and
# this particular banner has not yet been printed.
at_fn_banner ()
{
  $at_print_banners || return 0
  eval at_banner_text=\$at_banner_text_$1
  test "x$at_banner_text" = "x " && return 0
  eval "at_banner_text_$1=\" \""
  if test -z "$at_banner_text"; then
    $at_first || echo
  else
    $as_echo "$as_nl$at_banner_text$as_nl"
  fi
} # at_fn_banner

# at_fn_check_prepare_notrace REASON LINE
# ---------------------------------------
# Perform AT_CHECK preparations for the command at LINE for an untraceable
# command; REASON is the reason for disabling tracing.
at_fn_check_prepare_notrace ()
{
  $at_trace_echo "Not enabling shell tracing (command contains $1)"
  $as_echo "$2" >"$at_check_line_file"
  at_check_trace=: at_check_filter=:
  : >"$at_stdout"; : >"$at_stderr"
}

# at_fn_check_prepare_trace LINE
# ------------------------------
# Perform AT_CHECK preparations for the command at LINE for a traceable
# command.
at_fn_check_prepare_trace ()
{
  $as_echo "$1" >"$at_check_line_file"
  at_check_trace=$at_traceon at_check_filter=$at_check_filter_trace
  : >"$at_stdout"; : >"$at_stderr"
}

# at_fn_check_prepare_dynamic COMMAND LINE
# ----------------------------------------
# Decide if COMMAND at LINE is traceable at runtime, and call the appropriate
# preparation function.
at_fn_check_prepare_dynamic ()
{
  case $1 in
    *$as_nl*)
      at_fn_check_prepare_notrace 'an embedded newline' "$2" ;;
    *)
      at_fn_check_prepare_trace "$2" ;;
  esac
}

# at_fn_filter_trace
# ------------------
# Remove the lines in the file "$at_stderr" generated by "set -x" and print
# them to stderr.
at_fn_filter_trace ()
{
  mv "$at_stderr" "$at_stder1"
  grep '^ *+' "$at_stder1" >&2
  grep -v '^ *+' "$at_stder1" >"$at_stderr"
}

# at_fn_log_failure FILE-LIST
# ---------------------------
# Copy the files in the list on stdout with a "> " prefix, and exit the shell
# with a failure exit code.
at_fn_log_failure ()
{
  for file
    do $as_echo "$file:"; sed 's/^/> /' "$file"; done
  echo 1 > "$at_status_file"
  exit 1
}

# at_fn_check_skip EXIT-CODE LINE
# -------------------------------
# Check whether EXIT-CODE is a special exit code (77 or 99), and if so exit
# the test group subshell with that same exit code. Use LINE in any report
# about test failure.
at_fn_check_skip ()
{
  case $1 in
    99) echo 99 > "$at_status_file"; at_failed=:
	$as_echo "$2: hard failure"; exit 99;;
    77) echo 77 > "$at_status_file"; exit 77;;
  esac
}

# at_fn_check_status EXPECTED EXIT-CODE LINE
# ------------------------------------------
# Check whether EXIT-CODE is the EXPECTED exit code, and if so do nothing.
# Otherwise, if it is 77 or 99, exit the test group subshell with that same
# exit code; if it is anything else print an error message referring to LINE,
# and fail the test.
at_fn_check_status ()
{
  case $2 in
    $1 ) ;;
    77) echo 77 > "$at_status_file"; exit 77;;
    99) echo 99 > "$at_status_file"; at_failed=:
	$as_echo "$3: hard failure"; exit 99;;
    *) $as_echo "$3: exit code was $2, expected $1"
      at_failed=:;;
  esac
}

# at_fn_diff_devnull FILE
# -----------------------
# Emit a diff between /dev/null and FILE. Uses "test -s" to avoid useless diff
# invocations.
at_fn_diff_devnull ()
{
  test -s "$1" || return 0
  $at_diff "$at_devnull" "$1"
}

# at_fn_test NUMBER
# -----------------
# Parse out test NUMBER from the tail of this file.
at_fn_test ()
{
  eval at_sed=\$at_sed$1
  sed "$at_sed" "$at_myself" > "$at_test_source"
}

# at_fn_create_debugging_script
# -----------------------------
# Create the debugging script $at_group_dir/run which will reproduce the
# current test group.
at_fn_create_debugging_script ()
{
  {
    echo "#! /bin/sh" &&
    echo 'test "${ZSH_VERSION+set}" = set && alias -g '\''${1+"$@"}'\''='\''"$@"'\''' &&
    $as_echo "cd '$at_dir'" &&
    $as_echo "exec \${CONFIG_SHELL-$SHELL} \"$at_myself\" -v -d $at_debug_args $at_group \${1+\"\$@\"}" &&
    echo 'exit 1'
  } >"$at_group_dir/run" &&
  chmod +x "$at_group_dir/run"
}

## -------------------------------- ##
## End of autotest shell functions. ##
## -------------------------------- ##
{
  $as_echo "## ---------------- ##
## Tested programs. ##
## ---------------- ##"
  echo
} >&5

# Report what programs are being tested.
for at_program in : $at_tested
do
  test "$at_program" = : && continue
  case $at_program in
    [\\/]* | ?:[\\/]* ) $at_program_=$at_program ;;
    * )
    as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
for as_dir in $PATH
do
  IFS=$as_save_IFS
  test -z "$as_dir" && as_dir=.
    test -f "$as_dir/$at_program" && break
  done
IFS=$as_save_IFS

    at_program_=$as_dir/$at_program ;;
  esac
  if test -f "$at_program_"; then
    {
      $as_echo "$at_srcdir/local.at:27: $at_program_ --version"
      "$at_program_" --version </dev/null
      echo
    } >&5 2>&1
  else
    as_fn_error $? "cannot find $at_program" "$LINENO" 5
  fi
done

{
  $as_echo "## ------------------ ##
## Running the tests. ##
## ------------------ ##"
} >&5

at_start_date=`date`
at_start_time=`date +%s 2>/dev/null`
$as_echo "$as_me: starting at: $at_start_date" >&5

# Create the master directory if it doesn't already exist.
as_dir="$at_suite_dir"; as_fn_mkdir_p ||
  as_fn_error $? "cannot create \`$at_suite_dir'" "$LINENO" 5

# Can we diff with `/dev/null'?  DU 5.0 refuses.
if diff /dev/null /dev/null >/dev/null 2>&1; then
  at_devnull=/dev/null
else
  at_devnull=$at_suite_dir/devnull
  >"$at_devnull"
fi

# Use `diff -u' when possible.
if at_diff=`diff -u "$at_devnull" "$at_devnull" 2>&1` && test -z "$at_diff"
then
  at_diff='diff -u'
else
  at_diff=diff
fi

# Get the last needed group.
for at_group in : $at_groups; do :; done

# Extract the start and end lines of each test group at the tail
# of this file
awk '
BEGIN { FS="" }
/^#AT_START_/ {
  start = NR
}
/^#AT_STOP_/ {
  test = substr ($ 0, 10)
  print "at_sed" test "=\"1," start "d;" (NR-1) "q\""
  if (test == "'"$at_group"'") exit
}' "$at_myself" > "$at_suite_dir/at-source-lines" &&
. "$at_suite_dir/at-source-lines" ||
  as_fn_error $? "cannot create test line number cache" "$LINENO" 5
rm -f "$at_suite_dir/at-source-lines"

# Set number of jobs for `-j'; avoid more jobs than test groups.
set X $at_groups; shift; at_max_jobs=$#
if test $at_max_jobs -eq 0; then
  at_jobs=1
fi
if test $at_jobs -ne 1 &&
   { test $at_jobs -eq 0 || test $at_jobs -gt $at_max_jobs; }; then
  at_jobs=$at_max_jobs
fi

# If parallel mode, don't output banners, don't split summary lines.
if test $at_jobs -ne 1; then
  at_print_banners=false
  at_quiet=:
fi

# Set up helper dirs.
rm -rf "$at_helper_dir" &&
mkdir "$at_helper_dir" &&
cd "$at_helper_dir" &&
{ test -z "$at_groups" || mkdir $at_groups; } ||
as_fn_error $? "testsuite directory setup failed" "$LINENO" 5

# Functions for running a test group.  We leave the actual
# test group execution outside of a shell function in order
# to avoid hitting zsh 4.x exit status bugs.

# at_fn_group_prepare
# -------------------
# Prepare for running a test group.
at_fn_group_prepare ()
{
  # The directory for additional per-group helper files.
  at_job_dir=$at_helper_dir/$at_group
  # The file containing the location of the last AT_CHECK.
  at_check_line_file=$at_job_dir/check-line
  # The file containing the exit status of the last command.
  at_status_file=$at_job_dir/status
  # The files containing the output of the tested commands.
  at_stdout=$at_job_dir/stdout
  at_stder1=$at_job_dir/stder1
  at_stderr=$at_job_dir/stderr
  # The file containing the code for a test group.
  at_test_source=$at_job_dir/test-source
  # The file containing dates.
  at_times_file=$at_job_dir/times

  # Be sure to come back to the top test directory.
  cd "$at_suite_dir"

  # Clearly separate the test groups when verbose.
  $at_first || $at_verbose echo

  at_group_normalized=$at_group

  eval 'while :; do
    case $at_group_normalized in #(
    '"$at_format"'*) break;;
    esac
    at_group_normalized=0$at_group_normalized
  done'


  # Create a fresh directory for the next test group, and enter.
  # If one already exists, the user may have invoked ./run from
  # within that directory; we remove the contents, but not the
  # directory itself, so that we aren't pulling the rug out from
  # under the shell's notion of the current directory.
  at_group_dir=$at_suite_dir/$at_group_normalized
  at_group_log=$at_group_dir/$as_me.log
  if test -d "$at_group_dir"; then
  find "$at_group_dir" -type d ! -perm -700 -exec chmod u+rwx {} \;
  rm -fr "$at_group_dir"/* "$at_group_dir"/.[!.] "$at_group_dir"/.??*
fi ||
    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: test directory for $at_group_normalized could not be cleaned" >&5
$as_echo "$as_me: WARNING: test directory for $at_group_normalized could not be cleaned" >&2;}
  # Be tolerant if the above `rm' was not able to remove the directory.
  as_dir="$at_group_dir"; as_fn_mkdir_p

  echo 0 > "$at_status_file"

  # In verbose mode, append to the log file *and* show on
  # the standard output; in quiet mode only write to the log.
  if test -z "$at_verbose"; then
    at_tee_pipe='tee -a "$at_group_log"'
  else
    at_tee_pipe='cat >> "$at_group_log"'
  fi
}

# at_fn_group_banner ORDINAL LINE DESC PAD [BANNER]
# -------------------------------------------------
# Declare the test group ORDINAL, located at LINE with group description DESC,
# and residing under BANNER. Use PAD to align the status column.
at_fn_group_banner ()
{
  at_setup_line="$2"
  test -n "$5" && at_fn_banner $5
  at_desc="$3"
  case $1 in
    [0-9])      at_desc_line="  $1: ";;
    [0-9][0-9]) at_desc_line=" $1: " ;;
    *)          at_desc_line="$1: "  ;;
  esac
  as_fn_append at_desc_line "$3$4"
  $at_quiet $as_echo_n "$at_desc_line"
  echo "#                             -*- compilation -*-" >> "$at_group_log"
}

# at_fn_group_postprocess
# -----------------------
# Perform cleanup after running a test group.
at_fn_group_postprocess ()
{
  # Be sure to come back to the suite directory, in particular
  # since below we might `rm' the group directory we are in currently.
  cd "$at_suite_dir"

  if test ! -f "$at_check_line_file"; then
    sed "s/^ */$as_me: WARNING: /" <<_ATEOF
      A failure happened in a test group before any test could be
      run. This means that test suite is improperly designed.  Please
      report this failure to <kklic@redhat.com>.
_ATEOF
    $as_echo "$at_setup_line" >"$at_check_line_file"
    at_status=99
  fi
  $at_verbose $as_echo_n "$at_group. $at_setup_line: "
  $as_echo_n "$at_group. $at_setup_line: " >> "$at_group_log"
  case $at_xfail:$at_status in
    yes:0)
	at_msg="UNEXPECTED PASS"
	at_res=xpass
	at_errexit=$at_errexit_p
	at_color=$at_red
	;;
    no:0)
	at_msg="ok"
	at_res=pass
	at_errexit=false
	at_color=$at_grn
	;;
    *:77)
	at_msg='skipped ('`cat "$at_check_line_file"`')'
	at_res=skip
	at_errexit=false
	at_color=$at_blu
	;;
    no:* | *:99)
	at_msg='FAILED ('`cat "$at_check_line_file"`')'
	at_res=fail
	at_errexit=$at_errexit_p
	at_color=$at_red
	;;
    yes:*)
	at_msg='expected failure ('`cat "$at_check_line_file"`')'
	at_res=xfail
	at_errexit=false
	at_color=$at_lgn
	;;
  esac
  echo "$at_res" > "$at_job_dir/$at_res"
  # In parallel mode, output the summary line only afterwards.
  if test $at_jobs -ne 1 && test -n "$at_verbose"; then
    $as_echo "$at_desc_line $at_color$at_msg$at_std"
  else
    # Make sure there is a separator even with long titles.
    $as_echo " $at_color$at_msg$at_std"
  fi
  at_log_msg="$at_group. $at_desc ($at_setup_line): $at_msg"
  case $at_status in
    0|77)
      # $at_times_file is only available if the group succeeded.
      # We're not including the group log, so the success message
      # is written in the global log separately.  But we also
      # write to the group log in case they're using -d.
      if test -f "$at_times_file"; then
	at_log_msg="$at_log_msg     ("`sed 1d "$at_times_file"`')'
	rm -f "$at_times_file"
      fi
      $as_echo "$at_log_msg" >> "$at_group_log"
      $as_echo "$at_log_msg" >&5

      # Cleanup the group directory, unless the user wants the files
      # or the success was unexpected.
      if $at_debug_p || test $at_res = xpass; then
	at_fn_create_debugging_script
	if test $at_res = xpass && $at_errexit; then
	  echo stop > "$at_stop_file"
	fi
      else
	if test -d "$at_group_dir"; then
	  find "$at_group_dir" -type d ! -perm -700 -exec chmod u+rwx \{\} \;
	  rm -fr "$at_group_dir"
	fi
	rm -f "$at_test_source"
      fi
      ;;
    *)
      # Upon failure, include the log into the testsuite's global
      # log.  The failure message is written in the group log.  It
      # is later included in the global log.
      $as_echo "$at_log_msg" >> "$at_group_log"

      # Upon failure, keep the group directory for autopsy, and create
      # the debugging script.  With -e, do not start any further tests.
      at_fn_create_debugging_script
      if $at_errexit; then
	echo stop > "$at_stop_file"
      fi
      ;;
  esac
}


## ------------ ##
## Driver loop. ##
## ------------ ##


if (set -m && set +m && set +b) >/dev/null 2>&1; then
  set +b
  at_job_control_on='set -m' at_job_control_off='set +m' at_job_group=-
else
  at_job_control_on=: at_job_control_off=: at_job_group=
fi

for at_signal in 1 2 15; do
  trap 'set +x; set +e
	$at_job_control_off
	at_signal='"$at_signal"'
	echo stop > "$at_stop_file"
	trap "" $at_signal
	at_pgids=
	for at_pgid in `jobs -p 2>/dev/null`; do
	  at_pgids="$at_pgids $at_job_group$at_pgid"
	done
	test -z "$at_pgids" || kill -$at_signal $at_pgids 2>/dev/null
	wait
	if test "$at_jobs" -eq 1 || test -z "$at_verbose"; then
	  echo >&2
	fi
	at_signame=`kill -l $at_signal 2>&1 || echo $at_signal`
	set x $at_signame
	test 0 -gt 2 && at_signame=$at_signal
	{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: caught signal $at_signame, bailing out" >&5
$as_echo "$as_me: WARNING: caught signal $at_signame, bailing out" >&2;}
	as_fn_arith 128 + $at_signal && exit_status=$as_val
	as_fn_exit $exit_status' $at_signal
done

rm -f "$at_stop_file"
at_first=:

if test $at_jobs -ne 1 &&
     rm -f "$at_job_fifo" &&
     test -n "$at_job_group" &&
     ( mkfifo "$at_job_fifo" && trap 'exit 1' PIPE STOP TSTP ) 2>/dev/null
then
  # FIFO job dispatcher.

  trap 'at_pids=
	for at_pid in `jobs -p`; do
	  at_pids="$at_pids $at_job_group$at_pid"
	done
	if test -n "$at_pids"; then
	  at_sig=TSTP
	  test "${TMOUT+set}" = set && at_sig=STOP
	  kill -$at_sig $at_pids 2>/dev/null
	fi
	kill -STOP $$
	test -z "$at_pids" || kill -CONT $at_pids 2>/dev/null' TSTP

  echo
  # Turn jobs into a list of numbers, starting from 1.
  at_joblist=`$as_echo "$at_groups" | sed -n 1,${at_jobs}p`

  set X $at_joblist
  shift
  for at_group in $at_groups; do
    $at_job_control_on 2>/dev/null
    (
      # Start one test group.
      $at_job_control_off
      if $at_first; then
	exec 7>"$at_job_fifo"
      else
	exec 6<&-
      fi
      trap 'set +x; set +e
	    trap "" PIPE
	    echo stop > "$at_stop_file"
	    echo >&7
	    as_fn_exit 141' PIPE
      at_fn_group_prepare
      if cd "$at_group_dir" &&
	 at_fn_test $at_group &&
	 . "$at_test_source"
      then :; else
	{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: unable to parse test group: $at_group" >&5
$as_echo "$as_me: WARNING: unable to parse test group: $at_group" >&2;}
	at_failed=:
      fi
      at_fn_group_postprocess
      echo >&7
    ) &
    $at_job_control_off
    if $at_first; then
      at_first=false
      exec 6<"$at_job_fifo" 7>"$at_job_fifo"
    fi
    shift # Consume one token.
    if test $# -gt 0; then :; else
      read at_token <&6 || break
      set x $*
    fi
    test -f "$at_stop_file" && break
  done
  exec 7>&-
  # Read back the remaining ($at_jobs - 1) tokens.
  set X $at_joblist
  shift
  if test $# -gt 0; then
    shift
    for at_job
    do
      read at_token
    done <&6
  fi
  exec 6<&-
  wait
else
  # Run serially, avoid forks and other potential surprises.
  for at_group in $at_groups; do
    at_fn_group_prepare
    if cd "$at_group_dir" &&
       at_fn_test $at_group &&
       . "$at_test_source"; then :; else
      { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: unable to parse test group: $at_group" >&5
$as_echo "$as_me: WARNING: unable to parse test group: $at_group" >&2;}
      at_failed=:
    fi
    at_fn_group_postprocess
    test -f "$at_stop_file" && break
    at_first=false
  done
fi

# Wrap up the test suite with summary statistics.
cd "$at_helper_dir"

# Use ?..???? when the list must remain sorted, the faster * otherwise.
at_pass_list=`for f in */pass; do echo $f; done | sed '/\*/d; s,/pass,,'`
at_skip_list=`for f in */skip; do echo $f; done | sed '/\*/d; s,/skip,,'`
at_xfail_list=`for f in */xfail; do echo $f; done | sed '/\*/d; s,/xfail,,'`
at_xpass_list=`for f in ?/xpass ??/xpass ???/xpass ????/xpass; do
		 echo $f; done | sed '/?/d; s,/xpass,,'`
at_fail_list=`for f in ?/fail ??/fail ???/fail ????/fail; do
		echo $f; done | sed '/?/d; s,/fail,,'`

set X $at_pass_list $at_xpass_list $at_xfail_list $at_fail_list $at_skip_list
shift; at_group_count=$#
set X $at_xpass_list; shift; at_xpass_count=$#; at_xpass_list=$*
set X $at_xfail_list; shift; at_xfail_count=$#
set X $at_fail_list; shift; at_fail_count=$#; at_fail_list=$*
set X $at_skip_list; shift; at_skip_count=$#

as_fn_arith $at_group_count - $at_skip_count && at_run_count=$as_val
as_fn_arith $at_xpass_count + $at_fail_count && at_unexpected_count=$as_val
as_fn_arith $at_xfail_count + $at_fail_count && at_total_fail_count=$as_val

# Back to the top directory.
cd "$at_dir"
rm -rf "$at_helper_dir"

# Compute the duration of the suite.
at_stop_date=`date`
at_stop_time=`date +%s 2>/dev/null`
$as_echo "$as_me: ending at: $at_stop_date" >&5
case $at_start_time,$at_stop_time in
  [0-9]*,[0-9]*)
    as_fn_arith $at_stop_time - $at_start_time && at_duration_s=$as_val
    as_fn_arith $at_duration_s / 60 && at_duration_m=$as_val
    as_fn_arith $at_duration_m / 60 && at_duration_h=$as_val
    as_fn_arith $at_duration_s % 60 && at_duration_s=$as_val
    as_fn_arith $at_duration_m % 60 && at_duration_m=$as_val
    at_duration="${at_duration_h}h ${at_duration_m}m ${at_duration_s}s"
    $as_echo "$as_me: test suite duration: $at_duration" >&5
    ;;
esac

echo
$as_echo "## ------------- ##
## Test results. ##
## ------------- ##"
echo
{
  echo
  $as_echo "## ------------- ##
## Test results. ##
## ------------- ##"
  echo
} >&5

if test $at_run_count = 1; then
  at_result="1 test"
  at_were=was
else
  at_result="$at_run_count tests"
  at_were=were
fi
if $at_errexit_p && test $at_unexpected_count != 0; then
  if test $at_xpass_count = 1; then
    at_result="$at_result $at_were run, one passed"
  else
    at_result="$at_result $at_were run, one failed"
  fi
  at_result="$at_result unexpectedly and inhibited subsequent tests."
  at_color=$at_red
else
  # Don't you just love exponential explosion of the number of cases?
  at_color=$at_red
  case $at_xpass_count:$at_fail_count:$at_xfail_count in
    # So far, so good.
    0:0:0) at_result="$at_result $at_were successful." at_color=$at_grn ;;
    0:0:*) at_result="$at_result behaved as expected." at_color=$at_lgn ;;

    # Some unexpected failures
    0:*:0) at_result="$at_result $at_were run,
$at_fail_count failed unexpectedly." ;;

    # Some failures, both expected and unexpected
    0:*:1) at_result="$at_result $at_were run,
$at_total_fail_count failed ($at_xfail_count expected failure)." ;;
    0:*:*) at_result="$at_result $at_were run,
$at_total_fail_count failed ($at_xfail_count expected failures)." ;;

    # No unexpected failures, but some xpasses
    *:0:*) at_result="$at_result $at_were run,
$at_xpass_count passed unexpectedly." ;;

    # No expected failures, but failures and xpasses
    *:1:0) at_result="$at_result $at_were run,
$at_unexpected_count did not behave as expected ($at_fail_count unexpected failure)." ;;
    *:*:0) at_result="$at_result $at_were run,
$at_unexpected_count did not behave as expected ($at_fail_count unexpected failures)." ;;

    # All of them.
    *:*:1) at_result="$at_result $at_were run,
$at_xpass_count passed unexpectedly,
$at_total_fail_count failed ($at_xfail_count expected failure)." ;;
    *:*:*) at_result="$at_result $at_were run,
$at_xpass_count passed unexpectedly,
$at_total_fail_count failed ($at_xfail_count expected failures)." ;;
  esac

  if test $at_skip_count = 0 && test $at_run_count -gt 1; then
    at_result="All $at_result"
  fi
fi

# Now put skips in the mix.
case $at_skip_count in
  0) ;;
  1) at_result="$at_result
1 test was skipped." ;;
  *) at_result="$at_result
$at_skip_count tests were skipped." ;;
esac

if test $at_unexpected_count = 0; then
  echo "$at_color$at_result$at_std"
  echo "$at_result" >&5
else
  echo "${at_color}ERROR: $at_result$at_std" >&2
  echo "ERROR: $at_result" >&5
  {
    echo
    $as_echo "## ------------------------ ##
## Summary of the failures. ##
## ------------------------ ##"

    # Summary of failed and skipped tests.
    if test $at_fail_count != 0; then
      echo "Failed tests:"
      $SHELL "$at_myself" $at_fail_list --list
      echo
    fi
    if test $at_skip_count != 0; then
      echo "Skipped tests:"
      $SHELL "$at_myself" $at_skip_list --list
      echo
    fi
    if test $at_xpass_count != 0; then
      echo "Unexpected passes:"
      $SHELL "$at_myself" $at_xpass_list --list
      echo
    fi
    if test $at_fail_count != 0; then
      $as_echo "## ---------------------- ##
## Detailed failed tests. ##
## ---------------------- ##"
      echo
      for at_group in $at_fail_list
      do
	at_group_normalized=$at_group

  eval 'while :; do
    case $at_group_normalized in #(
    '"$at_format"'*) break;;
    esac
    at_group_normalized=0$at_group_normalized
  done'

	cat "$at_suite_dir/$at_group_normalized/$as_me.log"
	echo
      done
      echo
    fi
    if test -n "$at_top_srcdir"; then
      sed 'h;s/./-/g;s/^.../## /;s/...$/ ##/;p;x;p;x' <<_ASBOX
## ${at_top_build_prefix}config.log ##
_ASBOX
      sed 's/^/| /' ${at_top_build_prefix}config.log
      echo
    fi
  } >&5

  sed 'h;s/./-/g;s/^.../## /;s/...$/ ##/;p;x;p;x' <<_ASBOX
## $as_me.log was created. ##
_ASBOX

  echo
  if $at_debug_p; then
    at_msg='per-test log files'
  else
    at_msg="\`${at_testdir+${at_testdir}/}$as_me.log'"
  fi
  $as_echo "Please send $at_msg and all information you think might help:

   To: <kklic@redhat.com>
   Subject: [btparser 0.17] $as_me: $at_fail_list${at_fail_list:+ failed${at_xpass_list:+, }}$at_xpass_list${at_xpass_list:+ passed unexpectedly}

You may investigate any problem if you feel able to do so, in which
case the test suite provides a good starting point.  Its output may
be found below \`${at_testdir+${at_testdir}/}$as_me.dir'.
"
  exit 1
fi

exit 0

## ------------- ##
## Actual tests. ##
## ------------- ##
#AT_START_1
at_fn_group_banner 1 'utils.at:9' \
  "btp_strcmp0" "                                    " 1
at_xfail=no
(
  $as_echo "1. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >btp_strcmp0.c <<'_ATEOF'

#include <lib/utils.h>
#include <assert.h>
int main(void)
{
  assert(0 == btp_strcmp0(NULL, NULL));
  assert(0 == btp_strcmp0("abab", "abab"));
  assert(0 > btp_strcmp0("aba", "abab"));
  assert(0 > btp_strcmp0(NULL, "abab"));
  assert(0 < btp_strcmp0("abab", NULL));
  assert(0 < btp_strcmp0("abab", "aba"));
  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/utils.at:9: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o btp_strcmp0 btp_strcmp0.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o btp_strcmp0 btp_strcmp0.c $LIBS" "utils.at:9"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o btp_strcmp0 btp_strcmp0.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/utils.at:9"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/utils.at:9: ./btp_strcmp0"
at_fn_check_prepare_trace "utils.at:9"
( $at_check_trace; ./btp_strcmp0
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/utils.at:9"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_1
#AT_START_2
at_fn_group_banner 2 'utils.at:29' \
  "btp_strchr_location" "                            " 1
at_xfail=no
(
  $as_echo "2. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >btp_strchr_location.c <<'_ATEOF'

#include <lib/utils.h>
#include <assert.h>
int main(void)
{
  /* The character is on the first line.*/
  int line, column;
  char *result = btp_strchr_location("test string", 'r', &line, &column);
  assert(0 == strcmp(result, "ring"));
  assert(1 == line);
  assert(7 == column);

  /* The character is on the third line. */
  result = btp_strchr_location("\ntest\n string", 'r', &line, &column);
  assert(0 == strcmp(result, "ring"));
  assert(3 == line);
  assert(3 == column);

  /* The character is not found. */
  result = btp_strchr_location("\ntest\n string", 'z', &line, &column);
  assert(!result);

  /* The character _is_ a newline. */
  result = btp_strchr_location("abcd\nefgh", '\n', &line, &column);
  assert(0 == strcmp(result, "\nefgh"));
  assert(1 == line);
  assert(4 == column);
  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/utils.at:29: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o btp_strchr_location btp_strchr_location.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o btp_strchr_location btp_strchr_location.c $LIBS" "utils.at:29"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o btp_strchr_location btp_strchr_location.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/utils.at:29"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/utils.at:29: ./btp_strchr_location"
at_fn_check_prepare_trace "utils.at:29"
( $at_check_trace; ./btp_strchr_location
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/utils.at:29"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_2
#AT_START_3
at_fn_group_banner 3 'utils.at:65' \
  "btp_strstr_location" "                            " 1
at_xfail=no
(
  $as_echo "3. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >btp_strstr_location.c <<'_ATEOF'

#include <lib/utils.h>
#include <assert.h>
int main(void)
{
  /* The substring is on the first line.*/
  int line, column;
  char *result = btp_strstr_location("test string", "ri", &line, &column);
  assert(0 == strcmp(result, "ring"));
  assert(1 == line);
  assert(7 == column);

  /* The substring is on the third line. */
  result = btp_strstr_location("\ntest\n string", "ri", &line, &column);
  assert(0 == strcmp(result, "ring"));
  assert(3 == line);
  assert(3 == column);

  /* The substring is not found, but the first char is. */
  result = btp_strstr_location("\ntest\n string", "rz", &line, &column);
  assert(!result);

  /* The substring is not found. */
  result = btp_strstr_location("\ntest\n string", "zr", &line, &column);
  assert(!result);

  /* The substring _is_ a newline. */
  result = btp_strstr_location("abcd\nefgh", "\n", &line, &column);
  assert(0 == strcmp(result, "\nefgh"));
  assert(1 == line);
  assert(4 == column);
  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/utils.at:65: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o btp_strstr_location btp_strstr_location.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o btp_strstr_location btp_strstr_location.c $LIBS" "utils.at:65"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o btp_strstr_location btp_strstr_location.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/utils.at:65"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/utils.at:65: ./btp_strstr_location"
at_fn_check_prepare_trace "utils.at:65"
( $at_check_trace; ./btp_strstr_location
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/utils.at:65"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_3
#AT_START_4
at_fn_group_banner 4 'utils.at:105' \
  "btp_strspn_location" "                            " 1
at_xfail=no
(
  $as_echo "4. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >btp_strspn_location.c <<'_ATEOF'

#include <lib/utils.h>
#include <assert.h>
int main(void)
{
  /* No newline in the input.*/
  int line, column;
  size_t count = btp_strspn_location("test string",
                                     "tes ",
				     &line,
				     &column);
  assert(7 == count);
  assert(1 == line);
  assert(7 == column);

  /* With some newlines. */
  count = btp_strspn_location("te\nst \nstring",
                              "tes \n",
			      &line,
			      &column);
  assert(9 == count);
  assert(3 == line);
  assert(2 == column);

  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/utils.at:105: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o btp_strspn_location btp_strspn_location.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o btp_strspn_location btp_strspn_location.c $LIBS" "utils.at:105"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o btp_strspn_location btp_strspn_location.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/utils.at:105"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/utils.at:105: ./btp_strspn_location"
at_fn_check_prepare_trace "utils.at:105"
( $at_check_trace; ./btp_strspn_location
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/utils.at:105"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_4
#AT_START_5
at_fn_group_banner 5 'utils.at:138' \
  "btp_skip_char" "                                  " 1
at_xfail=no
(
  $as_echo "5. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >btp_skip_char.c <<'_ATEOF'

#include <lib/utils.h>
#include <assert.h>
int main(void)
{
  char *input = "abc";
  assert(btp_skip_char(&input, 'a'));
  assert(!btp_skip_char(&input, 'c'));
  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/utils.at:138: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o btp_skip_char btp_skip_char.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o btp_skip_char btp_skip_char.c $LIBS" "utils.at:138"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o btp_skip_char btp_skip_char.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/utils.at:138"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/utils.at:138: ./btp_skip_char"
at_fn_check_prepare_trace "utils.at:138"
( $at_check_trace; ./btp_skip_char
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/utils.at:138"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_5
#AT_START_6
at_fn_group_banner 6 'utils.at:155' \
  "btp_skip_char_limited" "                          " 1
at_xfail=no
(
  $as_echo "6. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >btp_skip_char_limited.c <<'_ATEOF'

#include <lib/utils.h>
#include <assert.h>
int main(void)
{
  char *input = "abc";
  assert(btp_skip_char_limited(&input, "ab"));
  assert(btp_skip_char_limited(&input, "ab"));
  assert(!btp_skip_char_limited(&input, "ab"));
  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/utils.at:155: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o btp_skip_char_limited btp_skip_char_limited.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o btp_skip_char_limited btp_skip_char_limited.c $LIBS" "utils.at:155"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o btp_skip_char_limited btp_skip_char_limited.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/utils.at:155"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/utils.at:155: ./btp_skip_char_limited"
at_fn_check_prepare_trace "utils.at:155"
( $at_check_trace; ./btp_skip_char_limited
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/utils.at:155"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_6
#AT_START_7
at_fn_group_banner 7 'utils.at:173' \
  "btp_parse_char_limited" "                         " 1
at_xfail=no
(
  $as_echo "7. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >btp_parse_char_limited.c <<'_ATEOF'

#include <lib/utils.h>
#include <assert.h>
int main(void)
{
  char *input = "abc";
  char result;

  /* First char in allowed is used. */
  assert(btp_parse_char_limited(&input, "ab", &result));
  assert(*input == 'b' && result == 'a');

  /* No char in allowed is used. */
  assert(!btp_parse_char_limited(&input, "cd", &result));
  assert(*input == 'b' && result == 'a');

  /* Second char in allowed is used. */
  assert(btp_parse_char_limited(&input, "ab", &result));
  assert(*input == 'c' && result == 'b');

  /* Empty set of allowed chars. */
  assert(!btp_parse_char_limited(&input, "", &result));
  assert(*input == 'c' && result == 'b');

  /* Char is multiple times in allowed. */
  assert(btp_parse_char_limited(&input, "cdc", &result));
  assert(*input == '\0' && result == 'c');

  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/utils.at:173: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o btp_parse_char_limited btp_parse_char_limited.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o btp_parse_char_limited btp_parse_char_limited.c $LIBS" "utils.at:173"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o btp_parse_char_limited btp_parse_char_limited.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/utils.at:173"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/utils.at:173: ./btp_parse_char_limited"
at_fn_check_prepare_trace "utils.at:173"
( $at_check_trace; ./btp_parse_char_limited
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/utils.at:173"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_7
#AT_START_8
at_fn_group_banner 8 'utils.at:210' \
  "btp_skip_char_sequence" "                         " 1
at_xfail=no
(
  $as_echo "8. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >btp_skip_char_sequence.c <<'_ATEOF'

#include <lib/utils.h>
#include <assert.h>
int main(void)
{
  char *input = "aaaaabc";
  assert(5 == btp_skip_char_sequence(&input, 'a'));
  assert(1 == btp_skip_char_sequence(&input, 'b'));
  assert(0 == btp_skip_char_sequence(&input, 'b'));
  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/utils.at:210: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o btp_skip_char_sequence btp_skip_char_sequence.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o btp_skip_char_sequence btp_skip_char_sequence.c $LIBS" "utils.at:210"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o btp_skip_char_sequence btp_skip_char_sequence.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/utils.at:210"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/utils.at:210: ./btp_skip_char_sequence"
at_fn_check_prepare_trace "utils.at:210"
( $at_check_trace; ./btp_skip_char_sequence
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/utils.at:210"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_8
#AT_START_9
at_fn_group_banner 9 'utils.at:228' \
  "btp_skip_char_span" "                             " 1
at_xfail=no
(
  $as_echo "9. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >btp_skip_char_span.c <<'_ATEOF'

#include <lib/utils.h>
#include <assert.h>
int main(void)
{
  char *input = "aabaabc";
  assert(6 == btp_skip_char_span(&input, "ba"));
  assert(0 == btp_skip_char_span(&input, "b"));
  assert(1 == btp_skip_char_span(&input, "bc"));

  /* Test that it can parse empty string. */
  assert(0 == btp_skip_char_span(&input, "abc"));

  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/utils.at:228: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o btp_skip_char_span btp_skip_char_span.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o btp_skip_char_span btp_skip_char_span.c $LIBS" "utils.at:228"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o btp_skip_char_span btp_skip_char_span.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/utils.at:228"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/utils.at:228: ./btp_skip_char_span"
at_fn_check_prepare_trace "utils.at:228"
( $at_check_trace; ./btp_skip_char_span
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/utils.at:228"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_9
#AT_START_10
at_fn_group_banner 10 'utils.at:250' \
  "btp_skip_char_span_location" "                    " 1
at_xfail=no
(
  $as_echo "10. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >btp_skip_char_span_location.c <<'_ATEOF'

#include <lib/utils.h>
#include <assert.h>
int main(void)
{
  char *input = "aab\naabc";
  int line, column;

  assert(7 == btp_skip_char_span_location(&input, "ba\n", &line, &column));
  assert(2 == line);
  assert(3 == column);

  assert(0 == btp_skip_char_span_location(&input, "b", &line, &column));
  assert(1 == line);
  assert(0 == column);

  assert(1 == btp_skip_char_span_location(&input, "bc", &line, &column));
  assert(1 == line);
  assert(1 == column);

  /* Test that it can parse empty string. */
  assert(0 == btp_skip_char_span_location(&input, "abc", &line, &column));
  assert(1 == line);
  assert(0 == column);

  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/utils.at:250: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o btp_skip_char_span_location btp_skip_char_span_location.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o btp_skip_char_span_location btp_skip_char_span_location.c $LIBS" "utils.at:250"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o btp_skip_char_span_location btp_skip_char_span_location.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/utils.at:250"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/utils.at:250: ./btp_skip_char_span_location"
at_fn_check_prepare_trace "utils.at:250"
( $at_check_trace; ./btp_skip_char_span_location
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/utils.at:250"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_10
#AT_START_11
at_fn_group_banner 11 'utils.at:284' \
  "btp_parse_char_span" "                            " 1
at_xfail=no
(
  $as_echo "11. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >btp_parse_char_span.c <<'_ATEOF'

#include <lib/utils.h>
#include <assert.h>
int main(void)
{
  char *input = "abcd";
  char *result;
  assert(2 == btp_parse_char_span(&input, "ba", &result));
  assert(*input == 'c' && strcmp(result, "ab") == 0);
  assert(0 == btp_parse_char_span(&input, "ba", &result));
  assert(*input == 'c' && strcmp(result, "ab") == 0);
  free(result);
  assert(2 == btp_parse_char_span(&input, "ecfd", &result));
  assert(*input == '\0' && strcmp(result, "cd") == 0);
  free(result);
  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/utils.at:284: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o btp_parse_char_span btp_parse_char_span.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o btp_parse_char_span btp_parse_char_span.c $LIBS" "utils.at:284"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o btp_parse_char_span btp_parse_char_span.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/utils.at:284"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/utils.at:284: ./btp_parse_char_span"
at_fn_check_prepare_trace "utils.at:284"
( $at_check_trace; ./btp_parse_char_span
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/utils.at:284"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_11
#AT_START_12
at_fn_group_banner 12 'utils.at:308' \
  "btp_parse_char_cspan" "                           " 1
at_xfail=no
(
  $as_echo "12. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >btp_parse_char_cspan.c <<'_ATEOF'

#include <lib/utils.h>
#include <assert.h>
int main(void)
{
  char *input = "abcd";
  char *result;
  assert(btp_parse_char_cspan(&input, "c", &result));
  assert(*input == 'c' && strcmp(result, "ab") == 0);
  assert(!btp_parse_char_cspan(&input, "c", &result));
  assert(*input == 'c' && strcmp(result, "ab") == 0);
  free(result);
  assert(btp_parse_char_cspan(&input, "e", &result));
  assert(*input == '\0' && strcmp(result, "cd") == 0);
  free(result);
  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/utils.at:308: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o btp_parse_char_cspan btp_parse_char_cspan.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o btp_parse_char_cspan btp_parse_char_cspan.c $LIBS" "utils.at:308"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o btp_parse_char_cspan btp_parse_char_cspan.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/utils.at:308"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/utils.at:308: ./btp_parse_char_cspan"
at_fn_check_prepare_trace "utils.at:308"
( $at_check_trace; ./btp_parse_char_cspan
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/utils.at:308"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_12
#AT_START_13
at_fn_group_banner 13 'utils.at:332' \
  "btp_skip_string" "                                " 1
at_xfail=no
(
  $as_echo "13. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >btp_skip_string.c <<'_ATEOF'

#include <lib/utils.h>
#include <assert.h>
int main(void)
{
  char *input = "abcd";
  assert(2 == btp_skip_string(&input, "ab"));
  assert(*input == 'c');
  assert(0 == btp_skip_string(&input, "cde"));
  assert(2 == btp_skip_string(&input, "cd"));
  assert(0 == btp_skip_string(&input, "cd"));
  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/utils.at:332: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o btp_skip_string btp_skip_string.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o btp_skip_string btp_skip_string.c $LIBS" "utils.at:332"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o btp_skip_string btp_skip_string.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/utils.at:332"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/utils.at:332: ./btp_skip_string"
at_fn_check_prepare_trace "utils.at:332"
( $at_check_trace; ./btp_skip_string
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/utils.at:332"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_13
#AT_START_14
at_fn_group_banner 14 'utils.at:352' \
  "btp_parse_string" "                               " 1
at_xfail=no
(
  $as_echo "14. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >btp_parse_string.c <<'_ATEOF'

#include <lib/utils.h>
#include <assert.h>
int main(void)
{
  char *input = "abcd";
  char *result;
  assert(btp_parse_string(&input, "ab", &result));
  assert(0 == strcmp(result, "ab"));
  assert(*input == 'c');
  free(result);
  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/utils.at:352: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o btp_parse_string btp_parse_string.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o btp_parse_string btp_parse_string.c $LIBS" "utils.at:352"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o btp_parse_string btp_parse_string.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/utils.at:352"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/utils.at:352: ./btp_parse_string"
at_fn_check_prepare_trace "utils.at:352"
( $at_check_trace; ./btp_parse_string
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/utils.at:352"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_14
#AT_START_15
at_fn_group_banner 15 'utils.at:372' \
  "btp_skip_unsigned_integer" "                      " 1
at_xfail=no
(
  $as_echo "15. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >btp_skip_unsigned_integer.c <<'_ATEOF'

#include <lib/utils.h>
#include <assert.h>
int main(void)
{
  char *input = "10";
  assert(2 == btp_skip_unsigned_integer(&input));
  assert(*input == '\0');
  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/utils.at:372: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o btp_skip_unsigned_integer btp_skip_unsigned_integer.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o btp_skip_unsigned_integer btp_skip_unsigned_integer.c $LIBS" "utils.at:372"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o btp_skip_unsigned_integer btp_skip_unsigned_integer.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/utils.at:372"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/utils.at:372: ./btp_skip_unsigned_integer"
at_fn_check_prepare_trace "utils.at:372"
( $at_check_trace; ./btp_skip_unsigned_integer
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/utils.at:372"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_15
#AT_START_16
at_fn_group_banner 16 'utils.at:389' \
  "btp_parse_unsigned_integer" "                     " 1
at_xfail=no
(
  $as_echo "16. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >btp_parse_unsigned_integer.c <<'_ATEOF'

#include <lib/utils.h>
#include <assert.h>
int main(void)
{
  char *input = "10";
  unsigned result;
  assert(2 == btp_parse_unsigned_integer(&input, &result));
  assert('\0' == *input);
  assert(10 == result);
  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/utils.at:389: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o btp_parse_unsigned_integer btp_parse_unsigned_integer.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o btp_parse_unsigned_integer btp_parse_unsigned_integer.c $LIBS" "utils.at:389"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o btp_parse_unsigned_integer btp_parse_unsigned_integer.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/utils.at:389"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/utils.at:389: ./btp_parse_unsigned_integer"
at_fn_check_prepare_trace "utils.at:389"
( $at_check_trace; ./btp_parse_unsigned_integer
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/utils.at:389"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_16
#AT_START_17
at_fn_group_banner 17 'utils.at:408' \
  "btp_skip_hexadecimal_number" "                    " 1
at_xfail=no
(
  $as_echo "17. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >btp_skip_hexadecimal_number.c <<'_ATEOF'

#include <lib/utils.h>
#include <assert.h>
int main(void)
{
  char *input = "0xffddffddff";
  assert(12 == btp_skip_hexadecimal_number(&input));
  assert(*input == '\0');
  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/utils.at:408: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o btp_skip_hexadecimal_number btp_skip_hexadecimal_number.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o btp_skip_hexadecimal_number btp_skip_hexadecimal_number.c $LIBS" "utils.at:408"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o btp_skip_hexadecimal_number btp_skip_hexadecimal_number.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/utils.at:408"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/utils.at:408: ./btp_skip_hexadecimal_number"
at_fn_check_prepare_trace "utils.at:408"
( $at_check_trace; ./btp_skip_hexadecimal_number
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/utils.at:408"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_17
#AT_START_18
at_fn_group_banner 18 'utils.at:425' \
  "btp_parse_hexadecimal_number" "                   " 1
at_xfail=no
(
  $as_echo "18. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >btp_parse_hexadecimal_number.c <<'_ATEOF'

#include <lib/utils.h>
#include <assert.h>
int main(void)
{
  char *input = "0x0fafaffff 0x2badf00dbaadf00d";
  uint64_t num;
  assert(11 == btp_parse_hexadecimal_number(&input, &num));
  assert(*input == ' ');
  assert(num == 0xfafaffff);
  *input++;
  assert(18 == btp_parse_hexadecimal_number(&input, &num));
  assert(*input == '\0');
  assert(num == 0x2badf00dbaadf00d);
  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/utils.at:425: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o btp_parse_hexadecimal_number btp_parse_hexadecimal_number.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o btp_parse_hexadecimal_number btp_parse_hexadecimal_number.c $LIBS" "utils.at:425"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o btp_parse_hexadecimal_number btp_parse_hexadecimal_number.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/utils.at:425"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/utils.at:425: ./btp_parse_hexadecimal_number"
at_fn_check_prepare_trace "utils.at:425"
( $at_check_trace; ./btp_parse_hexadecimal_number
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/utils.at:425"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_18
#AT_START_19
at_fn_group_banner 19 'strbuf.at:9' \
  "btp_strbuf_append_char" "                         " 2
at_xfail=no
(
  $as_echo "19. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >btp_strbuf_append_char.c <<'_ATEOF'

#include <lib/strbuf.h>
#include <assert.h>
int main(void)
{
  int i;
  struct btp_strbuf *strbuf = btp_strbuf_new();
  for (i = 0; i < 100; ++i)
  {
    assert(strbuf->len == i);
    assert(strbuf->alloc > strbuf->len);
    assert(strbuf->buf[i] == '\0');
    btp_strbuf_append_char(strbuf, 'a');
    assert(strbuf->buf[i] == 'a');
    assert(strbuf->buf[i+1] == '\0');
    assert(strbuf->len == i + 1);
    assert(strbuf->alloc > strbuf->len);
  }
  btp_strbuf_free(strbuf);
  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/strbuf.at:9: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o btp_strbuf_append_char btp_strbuf_append_char.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o btp_strbuf_append_char btp_strbuf_append_char.c $LIBS" "strbuf.at:9"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o btp_strbuf_append_char btp_strbuf_append_char.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/strbuf.at:9"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/strbuf.at:9: ./btp_strbuf_append_char"
at_fn_check_prepare_trace "strbuf.at:9"
( $at_check_trace; ./btp_strbuf_append_char
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/strbuf.at:9"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_19
#AT_START_20
at_fn_group_banner 20 'strbuf.at:37' \
  "btp_strbuf_append_str" "                          " 2
at_xfail=no
(
  $as_echo "20. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >btp_strbuf_append_str.c <<'_ATEOF'

#include <lib/strbuf.h>
#include <assert.h>

/* Test appending strings of certain length. 'len' must be < 50. */
void test(int len)
{
  int i;
  char str[50];
  for (i = 0; i < len; ++i)
    str[i] = 'a';
  str[i] = '\0';

  struct btp_strbuf *strbuf = btp_strbuf_new();
  for (i = 0; i < 100; ++i)
  {
    assert(strbuf->len == i*len);
    assert(strbuf->alloc > strbuf->len);
    assert(strbuf->buf[i*len] == '\0');
    btp_strbuf_append_str(strbuf, str);
    assert(strbuf->buf[i*len] == str[0]);
    assert(strbuf->buf[i*len+len] == '\0');
    assert(strbuf->len == i*len + len);
    assert(strbuf->alloc > strbuf->len);
  }
  btp_strbuf_free(strbuf);
}

int main(void)
{
  int i;
  for (i = 0; i < 50; ++i)
    test(i);
  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/strbuf.at:37: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o btp_strbuf_append_str btp_strbuf_append_str.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o btp_strbuf_append_str btp_strbuf_append_str.c $LIBS" "strbuf.at:37"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o btp_strbuf_append_str btp_strbuf_append_str.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/strbuf.at:37"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/strbuf.at:37: ./btp_strbuf_append_str"
at_fn_check_prepare_trace "strbuf.at:37"
( $at_check_trace; ./btp_strbuf_append_str
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/strbuf.at:37"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_20
#AT_START_21
at_fn_group_banner 21 'frame.at:9' \
  "btp_frame_dup" "                                  " 3
at_xfail=no
(
  $as_echo "21. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >btp_frame_dup.c <<'_ATEOF'

#include <lib/frame.h>
#include <lib/utils.h>
#include <assert.h>

int main(void)
{
  struct btp_frame *frame1 = btp_frame_new();;
  frame1->function_name = btp_strdup("test1");
  frame1->function_type = btp_strdup("type1");
  frame1->number = 10;
  frame1->source_file = btp_strdup("file1");
  frame1->source_line = 11;
  frame1->address = 12;

  struct btp_frame *frame0 = btp_frame_new();;
  frame0->function_name = btp_strdup("test0");
  frame0->function_type = btp_strdup("type0");
  frame0->number = 13;
  frame0->source_file = btp_strdup("file0");
  frame0->source_line = 14;
  frame0->address = 15;
  frame0->next = frame1;

  /* Test the duplication without siblings. */
  struct btp_frame *frame = btp_frame_dup(frame0, false);
  assert(NULL == frame->next);
  assert(frame->function_name != frame0->function_name);
  assert(frame->function_type != frame0->function_type);
  assert(frame->source_file != frame0->source_file);
  assert(0 == btp_frame_cmp(frame, frame0, true));
  btp_frame_free(frame);

  /* Test the duplication with the siblings. */
  frame = btp_frame_dup(frame0, true);
  assert(frame->function_name != frame0->function_name);
  assert(frame->function_type != frame0->function_type);
  assert(frame->source_file != frame0->source_file);
  assert(0 == btp_frame_cmp(frame, frame0, true));
  assert(frame->next != frame1);
  assert(0 == btp_frame_cmp(frame->next, frame1, true));
  btp_frame_free(frame->next);
  btp_frame_free(frame);

  btp_frame_free(frame1);
  btp_frame_free(frame0);
  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/frame.at:9: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o btp_frame_dup btp_frame_dup.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o btp_frame_dup btp_frame_dup.c $LIBS" "frame.at:9"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o btp_frame_dup btp_frame_dup.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/frame.at:9"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/frame.at:9: ./btp_frame_dup"
at_fn_check_prepare_trace "frame.at:9"
( $at_check_trace; ./btp_frame_dup
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/frame.at:9"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_21
#AT_START_22
at_fn_group_banner 22 'frame.at:64' \
  "btp_frame_parse_frame_start" "                    " 3
at_xfail=no
(
  $as_echo "22. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >btp_frame_parse_frame_start.c <<'_ATEOF'

#include <lib/frame.h>
#include <assert.h>

/**
 * @param input
 * The input text stream.
 * @param parsed_char_count
 * The expected number of characters parsed (taken) from input.
 * @param expected_frame_number
 * The expected parsed frame number.
 */
void check(char *input,
           int parsed_char_count,
           unsigned expected_frame_number)
{
  int number;
  char *old_input = input;
  assert(parsed_char_count == btp_frame_parse_frame_start(&input, &number));
  if (0 < parsed_char_count)
  {
    assert(number == expected_frame_number);
    assert(*input == '\0');
  }
  else
  {
    /* Check that the pointer is not moved. */
    assert(old_input == input);
  }
}

int main(void)
{
  check("#10 "    , 4, 10);
  check("#0  "    , 4, 0);
  check("#99999  ", 8, 99999);
  check("ab "     , 0, 0);
  check("#ab "    , 0, 0);
  check("#-9999 " , 0, 9999);
  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/frame.at:64: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o btp_frame_parse_frame_start btp_frame_parse_frame_start.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o btp_frame_parse_frame_start btp_frame_parse_frame_start.c $LIBS" "frame.at:64"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o btp_frame_parse_frame_start btp_frame_parse_frame_start.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/frame.at:64"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/frame.at:64: ./btp_frame_parse_frame_start"
at_fn_check_prepare_trace "frame.at:64"
( $at_check_trace; ./btp_frame_parse_frame_start
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/frame.at:64"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_22
#AT_START_23
at_fn_group_banner 23 'frame.at:112' \
  "btp_frame_parseadd_operator" "                    " 3
at_xfail=no
(
  $as_echo "23. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >btp_frame_parseadd_operator.c <<'_ATEOF'

#include <lib/frame.h>
#include <lib/strbuf.h>
#include <assert.h>
#include <string.h>

void check(char *input, int parsed_length)
{
  printf("Testing '%s' -> %d\n", input, parsed_length);
  char *old_input = input;
  struct btp_strbuf *strbuf = btp_strbuf_new();
  assert(parsed_length == btp_frame_parseadd_operator(&input, strbuf));
  printf("  input = '%s', old_input = '%s'\n", input, old_input);

  /* Check that the input pointer was updated properly. */
  assert(*input == old_input[parsed_length]);

  /* Check that the strbuf has been modified accordingly to what was parsed. */
  assert(0 == strncmp(strbuf->buf, old_input, parsed_length));
  assert(strbuf->len == parsed_length);

  btp_strbuf_free(strbuf);
}

int main(void)
{
  check("operator>", strlen("operator>"));
  check("operator->", strlen("operator->"));
  check("operator new", strlen("operator new"));
  check("operator new[]", strlen("operator new[]"));
  check("operator delete", strlen("operator delete"));
  check("operator del", 0);
  check("operator delete[] (test)", strlen("operator delete[]"));
  /* Red Hat Bugzilla bug #542445 */
  check("cairo_add_operator (test)", 0);
  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/frame.at:112: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o btp_frame_parseadd_operator btp_frame_parseadd_operator.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o btp_frame_parseadd_operator btp_frame_parseadd_operator.c $LIBS" "frame.at:112"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o btp_frame_parseadd_operator btp_frame_parseadd_operator.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/frame.at:112"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/frame.at:112: ./btp_frame_parseadd_operator"
at_fn_check_prepare_trace "frame.at:112"
( $at_check_trace; ./btp_frame_parseadd_operator
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/frame.at:112"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_23
#AT_START_24
at_fn_group_banner 24 'frame.at:156' \
  "btp_frame_parse_function_name" "                  " 3
at_xfail=no
(
  $as_echo "24. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >btp_frame_parse_function_name.c <<'_ATEOF'

#include <lib/frame.h>
#include <lib/utils.h>
#include <lib/location.h>
#include <assert.h>
#include <stdlib.h>
#include <string.h>

void check(bool success, char *input)
{
  /* Function name must be ended with a space. */
  char *input_with_space = btp_malloc(strlen(input) + 2);
  strcpy(input_with_space, input);
  input_with_space[strlen(input)] = ' ';
  input_with_space[strlen(input) + 1] = '\0';

  char *function_name = NULL, *function_type = NULL;
  char *old_input_with_space = input_with_space;
  printf("Parsing '%s'\n", input);
  struct btp_location location;
  btp_location_init(&location);
  assert(success == btp_frame_parse_function_name(&input_with_space,
						  &function_name,
						  &function_type,
						  &location));

  if (success)
  {
    assert(function_name);
    printf("Function name '%s'\n", function_name);
    assert(strcmp(function_name, input) == 0);
    assert(function_type == NULL);
    free(function_name);
    assert(*input_with_space == ' ');
  }
  else
  {
    /* Check that the pointer is not moved. */
    assert(old_input_with_space == input_with_space);
  }

  free(old_input_with_space);
}

int main(void)
{
  check(true, "??");
  check(true, "IA__g_bookmark_file_to_file");
  check(true, "pthread_cond_timedwait@@GLIBC_2.3.2");
  check(true, "_pixman_walk_composite_region");
  check(true, "CairoOutputDev::tilingPatternFill");
  check(true, "sdr::(anonymous namespace)::ViewContact::~ViewContact");
  check(true, "operator==<nsIAtom, nsICSSPseudoClass>");
  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/frame.at:156: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o btp_frame_parse_function_name btp_frame_parse_function_name.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o btp_frame_parse_function_name btp_frame_parse_function_name.c $LIBS" "frame.at:156"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o btp_frame_parse_function_name btp_frame_parse_function_name.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/frame.at:156"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/frame.at:156: ./btp_frame_parse_function_name"
at_fn_check_prepare_trace "frame.at:156"
( $at_check_trace; ./btp_frame_parse_function_name
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/frame.at:156"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_24
#AT_START_25
at_fn_group_banner 25 'frame.at:218' \
  "btp_frame_skip_function_args" "                   " 3
at_xfail=no
(
  $as_echo "25. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >btp_frame_skip_function_args.c <<'_ATEOF'

#include <lib/frame.h>
#include <lib/location.h>
#include <assert.h>

void check(bool success, char *input)
{
  char *old_input = input;
  struct btp_location location;
  btp_location_init(&location);
  assert(success == btp_frame_skip_function_args(&input, &location));
  if (success)
  {
    assert(*input == '\0');
  }
  else
  {
    /* Check that the pointer is not moved. */
    assert(old_input == input);
  }
}

int main(void)
{
  /* minimal */
  check(true, "()");
  /* newline */
  check(true, "(\n"
              "page=0x7f186003e280, \n"
	      "cairo=0x7f18600efd10, printing=0)");
  /* value optimized out */
  check(true, "(this=0x7f1860023400, DPI=<value optimized out>)");
  /* string */
  check(true, "(filename=0x18971b0 \"/home/jfclere/.recently-used.xbel\")");
  /* TODO: parentesis balance */
  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/frame.at:218: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o btp_frame_skip_function_args btp_frame_skip_function_args.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o btp_frame_skip_function_args btp_frame_skip_function_args.c $LIBS" "frame.at:218"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o btp_frame_skip_function_args btp_frame_skip_function_args.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/frame.at:218"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/frame.at:218: ./btp_frame_skip_function_args"
at_fn_check_prepare_trace "frame.at:218"
( $at_check_trace; ./btp_frame_skip_function_args
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/frame.at:218"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_25
#AT_START_26
at_fn_group_banner 26 'frame.at:262' \
  "btp_frame_parse_function_call" "                  " 3
at_xfail=no
(
  $as_echo "26. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >btp_frame_parse_function_call.c <<'_ATEOF'

#include <lib/frame.h>
#include <lib/location.h>
#include <assert.h>
#include <stdlib.h>
void check(bool success,
     	   char *input,
           char *expected_function_name,
	   char *expected_function_type)
{
  char *old_input = input;
  char *function_name, *function_type;
  struct btp_location location;
  btp_location_init(&location);
  assert(success == btp_frame_parse_function_call(&input,
                                                  &function_name,
						  &function_type,
                                                  &location));
  if (success)
  {
    printf("Expected: '%s', got '%s'\n", expected_function_name, function_name);
    assert(0 == strcmp(expected_function_name, function_name));
    assert((!expected_function_type && !function_type) ||
           0 == strcmp(expected_function_type, function_type));
    assert(*input == '\0');
    free(function_name);
  }
  else
  {
    /* Check that the pointer is not moved. */
    assert(old_input == input);
  }
}

int main(void)
{
  /* minimal */
  check(true, "?? ()", "??", NULL);
  check(true, "fsync ()", "fsync", NULL);
  /* newlines */
  check(true,
    "write_to_temp_file (\n"
      "filename=0x18971b0 \"/home/jfclere/.recently-used.xbel\", \n"
      "contents=<value optimized out>, length=29917, error=0x7fff3cbe4110)",
    "write_to_temp_file",
    NULL);
  /* C++ */
  check(true,
        "osgText::Font::GlyphTexture::apply(osg::State&) const ()",
  	"osgText::Font::GlyphTexture::apply(osg::State&) const",
        NULL);
  check(true,
        "osgUtil::RenderStage::drawInner(osg::RenderInfo&, osgUtil::RenderLeaf*&, bool&) ()",
        "osgUtil::RenderStage::drawInner(osg::RenderInfo&, osgUtil::RenderLeaf*&, bool&)",
	NULL);
  check(true,
        "nsRegion::RgnRect::operator new ()",
        "nsRegion::RgnRect::operator new",
        NULL);
  check(true,
        "sigc::internal::slot_call0<sigc::bound_mem_functor0<void, Driver>, void>::call_it (this=0x6c)",
        "sigc::internal::slot_call0<sigc::bound_mem_functor0<void, Driver>, void>::call_it",
        NULL);
  check(true,
        "sigc::internal::slot_call0<sigc::bound_mem_functor0<void, GameWindow>, void>::call_it(sigc::internal::slot_rep*) ()",
        "sigc::internal::slot_call0<sigc::bound_mem_functor0<void, GameWindow>, void>::call_it(sigc::internal::slot_rep*)",
        NULL);
  /* C++ operator< and templates */
  check(true,
	"operator< <char, std::char_traits<char>, std::allocator<char> > (__s1=<value optimized out>)",
        "operator< <char, std::char_traits<char>, std::allocator<char> >",
	NULL);
  /* C++ plain operator-> */
  check(true, "operator-> ()", "operator->", NULL);
  /* Not an operator, but includes the keyword 'operator' (Red Hat Bugzilla bug #542445) */
  check(true,
	"cairo_set_operator (cr=0x0, op=CAIRO_OPERATOR_OVER)",
	"cairo_set_operator",
	NULL);
  /* type included */
  #define TYPE "void"
  #define FUNCTION "boost::throw_exception<"                          \
  	  	   "boost::filesystem::basic_filesystem_error<"       \
		   "boost::filesystem::basic_path<"                   \
		   "std::basic_string<"                               \
		   "char, std::char_traits<char>, "                   \
		   "std::allocator<char> >, "                         \
		   "boost::filesystem::path_traits> > >"              \
		   "(boost::filesystem::basic_filesystem_error<"      \
		   "boost::filesystem::basic_path<"                   \
		   "std::basic_string<char, std::char_traits<char>, " \
	           "std::allocator<char> >, "                         \
		   "boost::filesystem::path_traits> > const&)"
  #define ARGS "()"
  #define FUNCALL TYPE " " FUNCTION " " ARGS
  check(true, FUNCALL, FUNCTION, TYPE);
  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/frame.at:262: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o btp_frame_parse_function_call btp_frame_parse_function_call.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o btp_frame_parse_function_call btp_frame_parse_function_call.c $LIBS" "frame.at:262"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o btp_frame_parse_function_call btp_frame_parse_function_call.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/frame.at:262"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/frame.at:262: ./btp_frame_parse_function_call"
at_fn_check_prepare_trace "frame.at:262"
( $at_check_trace; ./btp_frame_parse_function_call
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/frame.at:262"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_26
#AT_START_27
at_fn_group_banner 27 'frame.at:367' \
  "btp_frame_parse_address_in_function" "            " 3
at_xfail=no
(
  $as_echo "27. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >btp_frame_parse_address_in_function.c <<'_ATEOF'

#include <lib/frame.h>
#include <lib/location.h>
#include <assert.h>
#include <stdlib.h>
void check(bool success,
           char *input,
           uint64_t expected_address,
           char *expected_function)
{
  char *old_input = input;
  char *function;
  char *type;
  uint64_t address;
  struct btp_location location;
  btp_location_init(&location);
  assert(success == btp_frame_parse_address_in_function(&input,
						        &address,
							&function,
							&type,
							&location));
  if (success)
  {
    assert(strcmp(function, expected_function) == 0);
    assert(address == expected_address);
    assert(*input == '\0');
    free(function);
    free(type);
  }
  else
  {
    /* Check that the pointer is not moved. */
    assert(old_input == input);
  }
}

int main(void)
{
  /* minimal */
  check(true, "raise (sig=6)", -1, "raise");
  /* still simple */
  check(true, "0x00ad0a91 in raise (sig=6)", 0xad0a91, "raise");
  /* longnum */
  check(true, "0xf00000322221730e in IA__g_bookmark_file_to_file (\n"
    "filename=0x18971b0 \"/home/jfclere/.recently-used.xbel\", \n"
    "error=0x7fff3cbe4160)", 0xf00000322221730eULL,
    "IA__g_bookmark_file_to_file");
  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/frame.at:367: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o btp_frame_parse_address_in_function btp_frame_parse_address_in_function.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o btp_frame_parse_address_in_function btp_frame_parse_address_in_function.c $LIBS" "frame.at:367"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o btp_frame_parse_address_in_function btp_frame_parse_address_in_function.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/frame.at:367"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/frame.at:367: ./btp_frame_parse_address_in_function"
at_fn_check_prepare_trace "frame.at:367"
( $at_check_trace; ./btp_frame_parse_address_in_function
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/frame.at:367"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_27
#AT_START_28
at_fn_group_banner 28 'frame.at:423' \
  "btp_frame_parse_file_location" "                  " 3
at_xfail=no
(
  $as_echo "28. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >btp_frame_parse_file_location.c <<'_ATEOF'

#include <lib/frame.h>
#include <lib/location.h>
#include <assert.h>
#include <stdlib.h>
void check(bool success,
           char *input,
	   char *expected_file,
	   unsigned expected_line)
{
  char *old_input = input;
  char *file;
  unsigned line;
  struct btp_location location;
  btp_location_init(&location);
  assert(success == btp_frame_parse_file_location(&input,
					          &file,
                                                  &line,
						  &location));
  if (success)
  {
    assert(strcmp(file, expected_file) == 0);
    assert(line == expected_line);
    assert(*input == '\0');
    free(file);
  }
  else
  {
    /* Check that the pointer is not moved. */
    assert(old_input == input);
  }
}

int main(void)
{
  /* Test with a newline and without a line number. */
  check(true, "\n at gtkrecentmanager.c", "gtkrecentmanager.c", -1);

  /* Test with a newline and with a line number.  */
  check(true, "\n at gtkrecentmanager.c:1377", "gtkrecentmanager.c", 1377);

  /* Test without a newline and a file name with a dash and an upper letter. */
  check(true,
        " at ../sysdeps/unix/syscall-template.S:82",
        "../sysdeps/unix/syscall-template.S",
	82);

  /* A file name starting with an underscore: Red Hat Bugzilla bug #530678. */
  check(true,
        " at _polkitauthenticationagent.c:885",
        "_polkitauthenticationagent.c",
	885);

  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/frame.at:423: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o btp_frame_parse_file_location btp_frame_parse_file_location.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o btp_frame_parse_file_location btp_frame_parse_file_location.c $LIBS" "frame.at:423"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o btp_frame_parse_file_location btp_frame_parse_file_location.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/frame.at:423"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/frame.at:423: ./btp_frame_parse_file_location"
at_fn_check_prepare_trace "frame.at:423"
( $at_check_trace; ./btp_frame_parse_file_location
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/frame.at:423"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_28
#AT_START_29
at_fn_group_banner 29 'frame.at:485' \
  "btp_frame_parse_header" "                         " 3
at_xfail=no
(
  $as_echo "29. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >btp_frame_parse_header.c <<'_ATEOF'

#include <lib/frame.h>
#include <lib/location.h>
#include <assert.h>
#include <stdlib.h>
#include <stdio.h>

void check(char *input,
           struct btp_frame *expected_frame)
{
  printf("=================================================\n"
         "Testing %s\n",
	 input);

  char *old_input = input;
  struct btp_location location;
  btp_location_init(&location);
  struct btp_frame *frame = btp_frame_parse_header(&input, &location);
  if (frame)
  {
    assert(*input == '\0');
    assert(btp_frame_cmp(frame, expected_frame, true) == 0);
    btp_frame_free(frame);
  }
  else
  {
    printf(" - parsing failed: %d:%d %s\n", location.line, location.column, location.message);

    /* Check that the pointer is not moved. */
    assert(old_input == input);
    assert(!expected_frame);
  }
}

int main(void)
{
  /* no function address - rhbz#752811 */
  struct btp_frame frame;
  btp_frame_init(&frame);
  frame.function_name = "slot_tp_getattr_hook";
  frame.number = 0;
  frame.source_file = "/usr/src/debug/Python-2.7.1/Objects/typeobject.c";
  frame.source_line = 5436;
  frame.address = -1;
  check("#0  slot_tp_getattr_hook (self=<YumAvailableP...>) at /usr/src/debug/Python-2.7.1/Objects/typeobject.c:5436", &frame);

  /* basic */
  btp_frame_init(&frame);
  frame.function_name = "fsync";
  frame.number = 1;
  frame.source_file = "../sysdeps/unix/syscall-template.S";
  frame.source_line = 82;
  frame.address = 0x322160e7fdULL;
  check("#1  0x000000322160e7fd in fsync () at ../sysdeps/unix/syscall-template.S:82", &frame);

  /* C++ */
  btp_frame_init(&frame);
  frame.function_name = "nsRegion::RgnRect::operator new";
  frame.number = 4;
  frame.source_file = "nsRegion.cpp";
  frame.source_line = 214;
  frame.address = 0x3f96d71056ULL;
  check("#4  0x0000003f96d71056 in nsRegion::RgnRect::operator new ()\n"
        "    at nsRegion.cpp:214", &frame);

  /* Templates and no filename. */
  btp_frame_init(&frame);
  frame.function_name = "sigc::internal::slot_call0<sigc::bound_mem_functor0<void, GameWindow>, void>::call_it(sigc::internal::slot_rep*)";
  frame.number = 15;
  frame.address = 0x08201bdfULL;
  check("#15 0x08201bdf in sigc::internal::slot_call0<sigc::bound_mem_functor0<void, GameWindow>,"
        " void>::call_it(sigc::internal::slot_rep*) ()", &frame);

  /* No address, just the function call. Red Hat Bugzilla bug #530678 */
  btp_frame_init(&frame);
  frame.function_name = "handle_message";
  frame.number = 30;
  frame.source_file = "_polkitauthenticationagent.c";
  frame.source_line = 885;
  check("#30 handle_message (message=<value optimized out>,\n"
        "interface=<value optimized out>) at _polkitauthenticationagent.c:885", &frame);

  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/frame.at:485: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o btp_frame_parse_header btp_frame_parse_header.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o btp_frame_parse_header btp_frame_parse_header.c $LIBS" "frame.at:485"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o btp_frame_parse_header btp_frame_parse_header.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/frame.at:485"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/frame.at:485: ./btp_frame_parse_header"
at_fn_check_prepare_trace "frame.at:485"
( $at_check_trace; ./btp_frame_parse_header
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/frame.at:485"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_29
#AT_START_30
at_fn_group_banner 30 'frame.at:576' \
  "btp_frame_parse" "                                " 3
at_xfail=no
(
  $as_echo "30. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >btp_frame_parse.c <<'_ATEOF'

#include <lib/frame.h>
#include <lib/location.h>
#include <assert.h>
#include <stdlib.h>
#include <string.h>
void check(char *input,
           struct btp_frame *expected_frame,
	   char *expected_input,
	   struct btp_location *expected_location)
{
  char *old_input = input;
  struct btp_location location;
  btp_location_init(&location);
  struct btp_frame *frame = btp_frame_parse(&input, &location);
  assert(input == expected_input);
  if (frame)
  {
    assert(0 == btp_frame_cmp(frame, expected_frame, true));
    puts(btp_location_to_string(&location));
    puts(btp_location_to_string(expected_location));
    assert(0 == btp_location_cmp(&location, expected_location, true));
    btp_frame_free(frame);
  }
  else
  {
    /* Check that the pointer is not moved. */
    assert(old_input == input);
    assert(0 == btp_location_cmp(&location, expected_location, true));
    assert(!expected_frame);
  }
}

int main(void)
{
  /* basic */
  struct btp_frame frame;
  btp_frame_init(&frame);
  frame.function_name = "fsync";
  frame.number = 1;
  frame.source_file = "../sysdeps/unix/syscall-template.S";
  frame.source_line = 82;
  frame.address = 0x322160e7fdULL;
  char *c = "#1  0x000000322160e7fd in fsync () at ../sysdeps/unix/syscall-template.S:82\n"
            "No locals.";
  struct btp_location location;
  btp_location_init(&location);
  location.line = 2;
  location.column = 10;
  check(c, &frame, c + strlen(c), &location);

  c = "#1  0x000000322160e7fd in fsync () at ../sysdeps/unix/syscall-template.S:82\n"
      "No locals.\n"
      "#2  0x003f4f3f in IA__g_main_loop_run (loop=0x90e2c50) at gmain.c:2799\n"
      "        self = 0x8b80038\n"
      "  __PRETTY_FUNCTION__ = \"IA__g_main_loop_run\"\n";
  location.line = 3;
  location.column = 0;
  check(c, &frame, strstr(c, "#2"), &location);
  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/frame.at:576: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o btp_frame_parse btp_frame_parse.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o btp_frame_parse btp_frame_parse.c $LIBS" "frame.at:576"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o btp_frame_parse btp_frame_parse.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/frame.at:576"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/frame.at:576: ./btp_frame_parse"
at_fn_check_prepare_trace "frame.at:576"
( $at_check_trace; ./btp_frame_parse
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/frame.at:576"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_30
#AT_START_31
at_fn_group_banner 31 'thread.at:8' \
  "btp_thread_remove_frame" "                        " 4
at_xfail=no
(
  $as_echo "31. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >btp_thread_remove_frame.c <<'_ATEOF'

#include <lib/thread.h>
#include <lib/frame.h>
#include <lib/location.h>
#include <lib/utils.h>
#include <assert.h>
#include <stdlib.h>

int main(void)
{
  struct btp_frame *frame2 = btp_frame_new();
  frame2->function_name = btp_strdup("write");
  frame2->number = 2;
  frame2->source_file = btp_strdup("gfileutils.c");
  frame2->source_line = 120;
  frame2->address = 0x322160e7fdULL;

  struct btp_frame *frame1 = btp_frame_new();
  frame1->function_name = btp_strdup("write_to_temp_file");
  frame1->number = 1;
  frame1->source_file = btp_strdup("gfileutils.c");
  frame1->source_line = 980;
  frame1->address = 0x322160e7fdULL;
  frame1->next = frame2;

  struct btp_frame *frame0 = btp_frame_new();
  frame0->function_name = btp_strdup("fsync");
  frame0->number = 0;
  frame0->source_file = btp_strdup("../sysdeps/unix/syscall-template.S");
  frame0->source_line = 82;
  frame0->address = 0x322160e7fdULL;
  frame0->next = frame1;

  struct btp_thread thread;
  btp_thread_init(&thread);
  thread.number = 3;
  thread.frames = frame0;

  /* Remove the frame from the top of the stack. */
  assert(btp_thread_remove_frame(&thread, frame0));
  assert(frame1 == thread.frames);
  assert(frame2 == thread.frames->next);

  /* Remove the frame from the bottom of the stack. */
  assert(btp_thread_remove_frame(&thread, frame2));
  assert(frame1 == thread.frames);
  assert(NULL == thread.frames->next);

  /* Remove the last remaining frame. */
  assert(btp_thread_remove_frame(&thread, frame1));
  assert(NULL == thread.frames);

  /* Remove nonexistant frame -> should return false. */
  assert(!btp_thread_remove_frame(&thread, frame0));
  assert(NULL == thread.frames);

  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/thread.at:8: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o btp_thread_remove_frame btp_thread_remove_frame.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o btp_thread_remove_frame btp_thread_remove_frame.c $LIBS" "thread.at:8"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o btp_thread_remove_frame btp_thread_remove_frame.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/thread.at:8"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/thread.at:8: ./btp_thread_remove_frame"
at_fn_check_prepare_trace "thread.at:8"
( $at_check_trace; ./btp_thread_remove_frame
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/thread.at:8"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_31
#AT_START_32
at_fn_group_banner 32 'thread.at:72' \
  "btp_thread_remove_frames_above" "                 " 4
at_xfail=no
(
  $as_echo "32. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >btp_thread_remove_frames_above.c <<'_ATEOF'

#include <lib/thread.h>
#include <lib/frame.h>
#include <lib/location.h>
#include <lib/utils.h>
#include <assert.h>
#include <stdlib.h>

int main(void)
{
  struct btp_frame *frame2 = btp_frame_new();
  frame2->function_name = btp_strdup("write");
  frame2->number = 2;
  frame2->source_file = btp_strdup("gfileutils.c");
  frame2->source_line = 120;
  frame2->address = 0x322160e7fdULL;

  struct btp_frame *frame1 = btp_frame_new();
  frame1->function_name = btp_strdup("write_to_temp_file");
  frame1->number = 1;
  frame1->source_file = btp_strdup("gfileutils.c");
  frame1->source_line = 980;
  frame1->address = 0x322160e7fdULL;
  frame1->next = frame2;

  struct btp_frame *frame0 = btp_frame_new();
  frame0->function_name = btp_strdup("fsync");
  frame0->number = 0;
  frame0->source_file = btp_strdup("../sysdeps/unix/syscall-template.S");
  frame0->source_line = 82;
  frame0->address = 0x322160e7fdULL;
  frame0->next = frame1;

  struct btp_thread thread;
  btp_thread_init(&thread);
  thread.number = 3;
  thread.frames = frame0;

  /* Remove the frames above the top of the stack. */
  assert(btp_thread_remove_frames_above(&thread, frame0));
  assert(frame0 == thread.frames);
  assert(frame1 == thread.frames->next);

  /* Remove the frames above the second frame from the top of the stack. */
  assert(btp_thread_remove_frames_above(&thread, frame1));
  assert(frame1 == thread.frames);
  assert(frame2 == thread.frames->next);

  /* Remove the frames above the bottom of the stack. */
  assert(btp_thread_remove_frames_above(&thread, frame2));
  assert(frame2 == thread.frames);
  assert(NULL == thread.frames->next);

  /* Remove frames above a nonexistant frame -> should return false. */
  assert(!btp_thread_remove_frames_above(&thread, frame0));
  assert(frame2 == thread.frames);

  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/thread.at:72: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o btp_thread_remove_frames_above btp_thread_remove_frames_above.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o btp_thread_remove_frames_above btp_thread_remove_frames_above.c $LIBS" "thread.at:72"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o btp_thread_remove_frames_above btp_thread_remove_frames_above.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/thread.at:72"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/thread.at:72: ./btp_thread_remove_frames_above"
at_fn_check_prepare_trace "thread.at:72"
( $at_check_trace; ./btp_thread_remove_frames_above
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/thread.at:72"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_32
#AT_START_33
at_fn_group_banner 33 'thread.at:137' \
  "btp_thread_remove_frames_below_n" "               " 4
at_xfail=no
(
  $as_echo "33. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >btp_thread_remove_frames_below_n.c <<'_ATEOF'

#include <lib/thread.h>
#include <lib/frame.h>
#include <lib/location.h>
#include <lib/utils.h>
#include <assert.h>
#include <stdlib.h>

int main(void)
{
  struct btp_frame *frame2 = btp_frame_new();
  frame2->function_name = btp_strdup("write");
  frame2->number = 2;
  frame2->source_file = btp_strdup("gfileutils.c");
  frame2->source_line = 120;
  frame2->address = 0x322160e7fdULL;

  struct btp_frame *frame1 = btp_frame_new();
  frame1->function_name = btp_strdup("write_to_temp_file");
  frame1->number = 1;
  frame1->source_file = btp_strdup("gfileutils.c");
  frame1->source_line = 980;
  frame1->address = 0x322160e7fdULL;
  frame1->next = frame2;

  struct btp_frame *frame0 = btp_frame_new();
  frame0->function_name = btp_strdup("fsync");
  frame0->number = 0;
  frame0->source_file = btp_strdup("../sysdeps/unix/syscall-template.S");
  frame0->source_line = 82;
  frame0->address = 0x322160e7fdULL;
  frame0->next = frame1;

  struct btp_thread thread;
  btp_thread_init(&thread);
  thread.number = 3;
  thread.frames = frame0;

  /* Remove no frame as n is too large. */
  btp_thread_remove_frames_below_n(&thread, 5);
  assert(frame0 == thread.frames);
  assert(frame1 == thread.frames->next);
  assert(frame2 == thread.frames->next->next);
  assert(NULL == thread.frames->next->next->next);

  /* Remove the frames below 1. */
  btp_thread_remove_frames_below_n(&thread, 1);
  assert(frame0 == thread.frames);
  assert(NULL == thread.frames->next);

  /* Remove the frames below 0. */
  btp_thread_remove_frames_below_n(&thread, 0);
  assert(NULL == thread.frames);

  /* Try to remove frames when no frame is present. */
  btp_thread_remove_frames_below_n(&thread, 4);
  assert(NULL == thread.frames);

  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/thread.at:137: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o btp_thread_remove_frames_below_n btp_thread_remove_frames_below_n.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o btp_thread_remove_frames_below_n btp_thread_remove_frames_below_n.c $LIBS" "thread.at:137"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o btp_thread_remove_frames_below_n btp_thread_remove_frames_below_n.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/thread.at:137"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/thread.at:137: ./btp_thread_remove_frames_below_n"
at_fn_check_prepare_trace "thread.at:137"
( $at_check_trace; ./btp_thread_remove_frames_below_n
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/thread.at:137"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_33
#AT_START_34
at_fn_group_banner 34 'thread.at:204' \
  "btp_thread_parse" "                               " 4
at_xfail=no
(
  $as_echo "34. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >btp_thread_parse.c <<'_ATEOF'

#include <lib/thread.h>
#include <lib/frame.h>
#include <lib/location.h>
#include <assert.h>
#include <stdlib.h>
#include <stdio.h>

void check(char *input,
           struct btp_thread *expected_thread)
{
  printf("===============================================\n"
         "Testing input: %s",
	 input);

  char *old_input = input;
  struct btp_location location;
  btp_location_init(&location);
  struct btp_thread *thread = btp_thread_parse(&input, &location);
  assert(!expected_thread || thread);
  if (thread)
  {
    assert(*input == '\0');
    assert(0 == btp_thread_cmp(thread, expected_thread));
    btp_thread_free(thread);
  }
  else
  {
    /* Check that the pointer is not moved. */
    assert(old_input == input);
    assert(!expected_thread);
  }
}

int main(void)
{
  /* Basic test. */
  struct btp_frame frame0, frame1;
  btp_frame_init(&frame0);
  frame0.function_name = "fsync";
  frame0.number = 0;
  frame0.source_file = "../sysdeps/unix/syscall-template.S";
  frame0.source_line = 82;
  frame0.address = 0x322160e7fdULL;
  frame0.next = &frame1;

  btp_frame_init(&frame1);
  frame1.function_name = "write_to_temp_file";
  frame1.number = 1;
  frame1.source_file = "gfileutils.c";
  frame1.source_line = 980;
  frame1.address = 0x322160e7fdULL;

  struct btp_thread thread;
  btp_thread_init(&thread);
  thread.number = 3;
  thread.frames = &frame0;

  check("Thread 3 (Thread 11917):\n"
	"#0  0x000000322160e7fd in fsync () at ../sysdeps/unix/syscall-template.S:82\n"
	"No locals.\n"
	"#1  0x000000322222987a in write_to_temp_file (\n"
	"    filename=0x18971b0 \"/home/jfclere/.recently-used.xbel\", \n"
	"    contents=<value optimized out>, length=29917, error=0x7fff3cbe4110)\n"
	"    at gfileutils.c:980\n"
	"        statbuf = {st_dev = 64768, st_ino = 13709, st_nlink = 1, \n"
	"          st_mode = 33152, st_uid = 500, st_gid = 500, __pad0 = 0, \n"
	"          st_rdev = 0, st_size = 29917, st_blksize = 4096, st_blocks = 64, \n"
	"          st_atim = {tv_sec = 1273231242, tv_nsec = 73521863}, st_mtim = {\n"
	"            tv_sec = 1273231242, tv_nsec = 82521015}, st_ctim = {\n"
	"            tv_sec = 1273231242, tv_nsec = 190522021}, __unused = {0, 0, 0}}\n",
	&thread);

  /* Check that it also handles more exotic header. */
  check("Thread 3 (Thread 0xdd119170 (LWP 6357)):\n"
	"#0  0x000000322160e7fd in fsync () at ../sysdeps/unix/syscall-template.S:82\n"
	"No locals.\n"
	"#1  0x000000322222987a in write_to_temp_file () at gfileutils.c:980\n"
	"No locals.\n",
	&thread);

  /* Another format of the header. */
  check("Thread 3 (LWP 635):\n"
	"#0  0x000000322160e7fd in fsync () at ../sysdeps/unix/syscall-template.S:82\n"
	"No locals.\n"
	"#1  0x000000322222987a in write_to_temp_file () at gfileutils.c:980\n"
	"No locals.\n",
	&thread);

  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/thread.at:204: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o btp_thread_parse btp_thread_parse.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o btp_thread_parse btp_thread_parse.c $LIBS" "thread.at:204"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o btp_thread_parse btp_thread_parse.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/thread.at:204"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/thread.at:204: ./btp_thread_parse"
at_fn_check_prepare_trace "thread.at:204"
( $at_check_trace; ./btp_thread_parse
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/thread.at:204"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_34
#AT_START_35
at_fn_group_banner 35 'thread.at:302' \
  "btp_thread_parse-locations" "                     " 4
at_xfail=no
(
  $as_echo "35. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >btp_thread_parse-locations.c <<'_ATEOF'

#include <lib/thread.h>
#include <lib/frame.h>
#include <lib/location.h>
#include <assert.h>
#include <stdlib.h>

/**
 * Checks that the thread parser fails on ceratin location
 * (line and column), with an error message.
 */
void check(char *input,
           int expected_line,
	   int expected_column)
{
  char *old_input = input;
  struct btp_location location;
  btp_location_init(&location);
  assert(NULL == btp_thread_parse(&input, &location));

  /* Check that the pointer is not moved. */
  assert(old_input == input);

  /* Check the location. */
  printf("location %d:%d '%s', expected %d:%d\n",
         location.line, location.column, location.message,
	 expected_line, expected_column);

  assert(location.line == expected_line);
  assert(location.column == expected_column);
  assert(location.message);
  assert(location.message[0] != '\0');
}

int main(void)
{
  /* Thread keyword */
  check("Thraed 3 (Thread 11917):\n", 1, 0);

  /* Spaces after the thread keyword. */
  check("Thread3 (Thread 11917):\n", 1, 6);

  /* Thread number. */
  check("Thread  a (Thread 11917):\n", 1, 8);

  /* Spaces after the thread number. */
  check("Thread 8(Thread 11917):\n", 1, 8);

  /* A parenthesis. */
  check("Thread 8 (11917):\n", 1, 9);

  /* Second number. */
  check("Thread 8 (Thread ffff):\n", 1, 17);

  /* Semicolon missing. */
  check("Thread 8 (Thread 1)\n", 1, 18);

  /* Not a single frame. */
  check("Thread 3 (Thread 11917):\n\n", 2, 0);

  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/thread.at:302: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o btp_thread_parse-locations btp_thread_parse-locations.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o btp_thread_parse-locations btp_thread_parse-locations.c $LIBS" "thread.at:302"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o btp_thread_parse-locations btp_thread_parse-locations.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/thread.at:302"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/thread.at:302: ./btp_thread_parse-locations"
at_fn_check_prepare_trace "thread.at:302"
( $at_check_trace; ./btp_thread_parse-locations
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/thread.at:302"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_35
#AT_START_36
at_fn_group_banner 36 'thread.at:371' \
  "btp_thread_skip_lwp" "                            " 4
at_xfail=no
(
  $as_echo "36. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >btp_thread_skip_lwp.c <<'_ATEOF'

#include <lib/thread.h>
#include <assert.h>
#include <stdlib.h>

void check(char *input,
           int expected_count)
{
  char *old_input = input;
  assert(expected_count == btp_thread_skip_lwp(&input));
  assert(input - old_input == expected_count);
}

int main(void)
{
  check("(LWP 20)", 8);
  check("(LWP 20)10", 8);
  check("(LWP 245443452355454343450)", 27);
  check("(LWP 245443452355454343450)  ", 27);

  check("", 0);
  check(" ", 0);
  check(" (LWP 20)", 0);
  check("(LWP", 0);
  check("(LWP 20", 0);
  check("(LWP )", 0);
  check("(LWP 20()", 0);
  check("(LWP 0x0)", 0);
  check("(LWP 20(", 0);

  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/thread.at:371: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o btp_thread_skip_lwp btp_thread_skip_lwp.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o btp_thread_skip_lwp btp_thread_skip_lwp.c $LIBS" "thread.at:371"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o btp_thread_skip_lwp btp_thread_skip_lwp.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/thread.at:371"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/thread.at:371: ./btp_thread_skip_lwp"
at_fn_check_prepare_trace "thread.at:371"
( $at_check_trace; ./btp_thread_skip_lwp
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/thread.at:371"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_36
#AT_START_37
at_fn_group_banner 37 'backtrace.at:8' \
  "btp_backtrace_remove_threads_except_one" "        " 5
at_xfail=no
(
  $as_echo "37. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >btp_backtrace_remove_threads_except_one.c <<'_ATEOF'

#include <lib/backtrace.h>
#include <lib/thread.h>
#include <assert.h>
#include <stdlib.h>

int main(void)
{
  /* Delete the thread except the middle one. */
  struct btp_thread *thread2 = btp_thread_new();
  struct btp_thread *thread1 = btp_thread_new();
  thread1->next = thread2;
  struct btp_thread *thread0 = btp_thread_new();
  thread0->next = thread1;
  struct btp_backtrace *backtrace = btp_backtrace_new();
  backtrace->threads = thread0;
  btp_backtrace_remove_threads_except_one(backtrace, thread1);
  assert(backtrace->threads == thread1);
  assert(NULL == backtrace->threads->next);

  /* Delete all threads except one when there is only one. */
  btp_backtrace_remove_threads_except_one(backtrace, thread1);
  assert(backtrace->threads == thread1);
  assert(NULL == backtrace->threads->next);

  /* Delete all threads except the first one. */
  thread0 = btp_thread_new();
  backtrace->threads = thread0;
  thread0->next = thread1; // already exists
  thread2 = btp_thread_new();
  thread1->next = thread2;
  btp_backtrace_remove_threads_except_one(backtrace, thread0);
  assert(backtrace->threads == thread0);
  assert(NULL == backtrace->threads->next);

  /* Delete all threads except the last one. */
  thread1 = btp_thread_new();
  thread0->next = thread1;
  thread2 = btp_thread_new();
  thread1->next = thread2;
  btp_backtrace_remove_threads_except_one(backtrace, thread2);
  assert(backtrace->threads == thread2);
  assert(NULL == backtrace->threads->next);

  btp_backtrace_free(backtrace);
  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/backtrace.at:8: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o btp_backtrace_remove_threads_except_one btp_backtrace_remove_threads_except_one.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o btp_backtrace_remove_threads_except_one btp_backtrace_remove_threads_except_one.c $LIBS" "backtrace.at:8"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o btp_backtrace_remove_threads_except_one btp_backtrace_remove_threads_except_one.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/backtrace.at:8"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/backtrace.at:8: ./btp_backtrace_remove_threads_except_one"
at_fn_check_prepare_trace "backtrace.at:8"
( $at_check_trace; ./btp_backtrace_remove_threads_except_one
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/backtrace.at:8"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_37
#AT_START_38
at_fn_group_banner 38 'backtrace.at:61' \
  "btp_backtrace_find_crash_thread" "                " 5
at_xfail=no
(
  $as_echo "38. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >btp_backtrace_find_crash_thread.c <<'_ATEOF'

#include <lib/backtrace.h>
#include <lib/thread.h>
#include <lib/frame.h>
#include <lib/location.h>
#include <lib/utils.h>
#include <assert.h>

int main(void)
{
  /* Load the backtrace from Red Hat Bugzilla bug #621492. */
  struct btp_location location;
  btp_location_init(&location);
  char *full_input = btp_file_to_string("../../backtraces/621492.bt");
  assert(full_input);
  char *input = full_input;
  struct btp_backtrace *backtrace = btp_backtrace_parse(&input, &location);
  assert(backtrace);

  /* Check that the crash thread is found. */
  struct btp_thread *crash_thread = btp_backtrace_find_crash_thread(backtrace);
  assert(crash_thread);
  assert(0 == strcmp(crash_thread->frames->function_name, "raise"));
  btp_backtrace_free(backtrace);
  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/backtrace.at:61: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o btp_backtrace_find_crash_thread btp_backtrace_find_crash_thread.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o btp_backtrace_find_crash_thread btp_backtrace_find_crash_thread.c $LIBS" "backtrace.at:61"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o btp_backtrace_find_crash_thread btp_backtrace_find_crash_thread.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/backtrace.at:61"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/backtrace.at:61: ./btp_backtrace_find_crash_thread"
at_fn_check_prepare_trace "backtrace.at:61"
( $at_check_trace; ./btp_backtrace_find_crash_thread
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/backtrace.at:61"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_38
#AT_START_39
at_fn_group_banner 39 'backtrace.at:93' \
  "btp_backtrace_limit_frame_depth" "                " 5
at_xfail=no
(
  $as_echo "39. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >btp_backtrace_limit_frame_depth.c <<'_ATEOF'

#include <lib/backtrace.h>
#include <lib/thread.h>
#include <lib/location.h>
#include <lib/utils.h>
#include <assert.h>

int main(void)
{
  /* Load the backtrace from Red Hat Bugzilla bug #621492. */
  struct btp_location location;
  btp_location_init(&location);
  char *full_input = btp_file_to_string("../../backtraces/621492.bt");
  assert(full_input);
  char *input = full_input;
  struct btp_backtrace *backtrace = btp_backtrace_parse(&input, &location);
  assert(backtrace);

  /* Check the frame depth limit. */
  btp_backtrace_limit_frame_depth(backtrace, 5);
  assert(11 == btp_backtrace_get_thread_count(backtrace));
  struct btp_thread *thread = backtrace->threads;
  while (thread)
  {
    assert(5 == btp_thread_get_frame_count(thread));
    thread = thread->next;
  }

  btp_backtrace_free(backtrace);
  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/backtrace.at:93: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o btp_backtrace_limit_frame_depth btp_backtrace_limit_frame_depth.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o btp_backtrace_limit_frame_depth btp_backtrace_limit_frame_depth.c $LIBS" "backtrace.at:93"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o btp_backtrace_limit_frame_depth btp_backtrace_limit_frame_depth.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/backtrace.at:93"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/backtrace.at:93: ./btp_backtrace_limit_frame_depth"
at_fn_check_prepare_trace "backtrace.at:93"
( $at_check_trace; ./btp_backtrace_limit_frame_depth
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/backtrace.at:93"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_39
#AT_START_40
at_fn_group_banner 40 'backtrace.at:130' \
  "btp_backtrace_quality_complex" "                  " 5
at_xfail=no
(
  $as_echo "40. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >btp_backtrace_quality_complex.c <<'_ATEOF'

#include <lib/backtrace.h>
#include <lib/thread.h>
#include <lib/location.h>
#include <lib/utils.h>
#include <assert.h>

int main(void)
{
  /* Load the backtrace from Red Hat Bugzilla bug #621492. */
  struct btp_location location;
  btp_location_init(&location);
  char *full_input = btp_file_to_string("../../backtraces/621492.bt");
  assert(full_input);
  char *input = full_input;
  struct btp_backtrace *backtrace = btp_backtrace_parse(&input, &location);
  assert(backtrace);
  assert(1.0f == btp_backtrace_quality_complex(backtrace));
  btp_backtrace_free(backtrace);
  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/backtrace.at:130: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o btp_backtrace_quality_complex btp_backtrace_quality_complex.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o btp_backtrace_quality_complex btp_backtrace_quality_complex.c $LIBS" "backtrace.at:130"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o btp_backtrace_quality_complex btp_backtrace_quality_complex.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/backtrace.at:130"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/backtrace.at:130: ./btp_backtrace_quality_complex"
at_fn_check_prepare_trace "backtrace.at:130"
( $at_check_trace; ./btp_backtrace_quality_complex
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/backtrace.at:130"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_40
#AT_START_41
at_fn_group_banner 41 'normalize.at:44' \
  "btp_normalize_thread_removes_zeroes" "            " 6
at_xfail=no
(
  $as_echo "41. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >btp_normalize_thread_removes_zeroes.c <<'_ATEOF'

#include <lib/normalize.h>
#include <lib/frame.h>
#include <lib/thread.h>
#include <lib/utils.h>
#include <assert.h>
#include <stdlib.h>

int main(void)
{
  struct btp_frame *frame2 = btp_frame_new();
  frame2->function_name = btp_strdup("??");
  frame2->number = 2;
  frame2->address = 0x0000;

  struct btp_frame *frame1 = btp_frame_new();
  frame1->function_name = btp_strdup("write_to_temp_file");
  frame1->number = 1;
  frame1->source_file = btp_strdup("gfileutils.c");
  frame1->source_line = 980;
  frame1->address = 0x322160e7fdULL;
  frame1->next = frame2;

  struct btp_frame *frame0 = btp_frame_new();
  frame0->function_name = btp_strdup("??");
  frame0->number = 0;
  frame0->address = 0x0000;
  frame0->next = frame1;

  struct btp_thread thread;
  btp_thread_init(&thread);
  thread.number = 0;
  thread.frames = frame0;

  btp_normalize_thread(&thread);
  assert(thread.frames == frame1);
  assert(thread.frames->next == NULL);

  btp_frame_free(frame1);
  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/normalize.at:44: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o btp_normalize_thread_removes_zeroes btp_normalize_thread_removes_zeroes.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o btp_normalize_thread_removes_zeroes btp_normalize_thread_removes_zeroes.c $LIBS" "normalize.at:44"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o btp_normalize_thread_removes_zeroes btp_normalize_thread_removes_zeroes.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/normalize.at:44"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/normalize.at:44: ./btp_normalize_thread_removes_zeroes"
at_fn_check_prepare_trace "normalize.at:44"
( $at_check_trace; ./btp_normalize_thread_removes_zeroes
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/normalize.at:44"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_41
#AT_START_42
at_fn_group_banner 42 'normalize.at:88' \
  "btp_normalize_paired_unknown_function_names" "    " 6
at_xfail=no
(
  $as_echo "42. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >btp_normalize_paired_unknown_function_names.c <<'_ATEOF'

#include <stdarg.h>
#include <lib/thread.h>
#include <lib/frame.h>
#include <lib/utils.h>
#include <stdlib.h>
#include <assert.h>
#include <lib/metrics.h>
#include <lib/normalize.h>

struct btp_thread *create_thread(int count, ...)
{
  struct btp_thread *thread = btp_thread_new();
  if (count == 0)
     return thread;
  int i;
  va_list argp;
  va_start(argp, count);

  for (i=0; i < count; i++)
  {
    const char *fname = va_arg(argp, const char*);
    struct btp_frame *frame = btp_frame_new();
    frame->function_name = btp_strdup(fname);

    if (thread->frames == NULL)thread->frames = frame;
    else btp_frame_add_sibling(thread->frames, frame);
  }

  va_end(argp);
  return thread;
}


int main()
{
  struct btp_thread *threads[6];
  struct btp_frame *frame;
  threads[0] = create_thread(5, "aa", "??", "??", "??", "??");
  threads[1] = create_thread(5, "bb", "aa", "??", "??", "??");
  threads[2] = create_thread(5, "aa", "??", "??", "??", "??");
  threads[3] = create_thread(5, "bb", "aa", "??", "??", "??");

  threads[4] = btp_thread_dup(threads[0], false);
  threads[5] = btp_thread_dup(threads[1], false);
  btp_normalize_paired_unknown_function_names(threads[4], threads[5]);
  assert(!btp_thread_cmp(threads[2], threads[4]));
  assert(!btp_thread_cmp(threads[3], threads[5]));

  threads[4] = btp_thread_dup(threads[0], false);
  threads[5] = btp_thread_dup(threads[1], false);
  btp_normalize_paired_unknown_function_names(threads[5], threads[4]);
  assert(!btp_thread_cmp(threads[2], threads[4]));
  assert(!btp_thread_cmp(threads[3], threads[5]));

  threads[0] = create_thread(5, "aa", "??", "cc", "cc", "??");
  threads[1] = create_thread(5, "bb", "aa", "??", "cc", "??");
  threads[2] = create_thread(5, "aa", "__unknown_function_0", "cc", "cc", "__unknown_function_1");
  threads[3] = create_thread(5, "bb", "aa","__unknown_function_0", "cc", "__unknown_function_1");

  threads[4] = btp_thread_dup(threads[0], false);
  threads[5] = btp_thread_dup(threads[1], false);
  btp_normalize_paired_unknown_function_names(threads[4], threads[5]);
  assert(!btp_thread_cmp(threads[2], threads[4]));
  assert(!btp_thread_cmp(threads[3], threads[5]));

  threads[0] = create_thread(5, "aa", "??", "cc", "??", "dd");
  threads[1] = create_thread(5, "bb", "??", "cc", "??", "dd");
  threads[2] = create_thread(5, "aa", "??", "cc", "__unknown_function_0", "dd");
  threads[3] = create_thread(5, "bb", "??", "cc", "__unknown_function_0", "dd");

  threads[4] = btp_thread_dup(threads[0], false);
  threads[5] = btp_thread_dup(threads[1], false);
  btp_normalize_paired_unknown_function_names(threads[4], threads[5]);
  assert(!btp_thread_cmp(threads[2], threads[4]));
  assert(!btp_thread_cmp(threads[3], threads[5]));

  threads[0] = create_thread(5, "aa", "cc", "??", "??", "??");
  threads[1] = create_thread(5, "bb", "??", "??", "??", "??");
  threads[2] = create_thread(5, "aa", "cc", "??", "??", "??");
  threads[3] = create_thread(5, "bb", "??", "??", "??", "??");

  threads[4] = btp_thread_dup(threads[0], false);
  threads[5] = btp_thread_dup(threads[1], false);
  btp_normalize_paired_unknown_function_names(threads[4], threads[5]);
  assert(!btp_thread_cmp(threads[2], threads[4]));
  assert(!btp_thread_cmp(threads[3], threads[5]));

  threads[4] = btp_thread_dup(threads[0], false);
  threads[5] = btp_thread_dup(threads[1], false);
  btp_normalize_paired_unknown_function_names(threads[5], threads[4]);
  assert(!btp_thread_cmp(threads[2], threads[4]));
  assert(!btp_thread_cmp(threads[3], threads[5]));

  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/normalize.at:88: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o btp_normalize_paired_unknown_function_names btp_normalize_paired_unknown_function_names.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o btp_normalize_paired_unknown_function_names btp_normalize_paired_unknown_function_names.c $LIBS" "normalize.at:88"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o btp_normalize_paired_unknown_function_names btp_normalize_paired_unknown_function_names.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/normalize.at:88"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/normalize.at:88: ./btp_normalize_paired_unknown_function_names"
at_fn_check_prepare_trace "normalize.at:88"
( $at_check_trace; ./btp_normalize_paired_unknown_function_names
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/normalize.at:88"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_42
#AT_START_43
at_fn_group_banner 43 'metrics.at:43' \
  "metrics_all_one_thread_empty" "                   " 7
at_xfail=no
(
  $as_echo "43. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >metrics_all_one_thread_empty.c <<'_ATEOF'

#include <stdarg.h>
#include <lib/thread.h>
#include <lib/frame.h>
#include <lib/utils.h>
#include <stdlib.h>
#include <assert.h>
#include <lib/metrics.h>
#include <lib/normalize.h>

struct btp_thread *create_thread(int count, ...)
{
  struct btp_thread *thread = btp_thread_new();
  if (count == 0)
     return thread;
  int i;
  va_list argp;
  va_start(argp, count);

  for (i=0; i < count; i++)
  {
    const char *fname = va_arg(argp, const char*);
    struct btp_frame *frame = btp_frame_new();
    frame->function_name = btp_strdup(fname);

    if (thread->frames == NULL)thread->frames = frame;
    else btp_frame_add_sibling(thread->frames, frame);
  }

  va_end(argp);
  return thread;
}

bool is_dist_equal(float x, float y)
{
  float epsilon = 1e-6;
  return x - epsilon <= y && x + epsilon >= y;
}


int main()
{
  struct btp_thread *thread1 = create_thread(0);

  struct btp_thread *thread2 = create_thread(3, "??", "ds", "main");

  btp_normalize_paired_unknown_function_names(thread1, thread2);

  assert(is_dist_equal(0.0, btp_thread_jarowinkler_distance(thread1, thread2)));
  assert(is_dist_equal(1.0, btp_thread_jaccard_distance(thread1, thread2)));
  assert(3 == btp_thread_levenshtein_distance(thread1, thread2, false));
  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/metrics.at:43: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o metrics_all_one_thread_empty metrics_all_one_thread_empty.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o metrics_all_one_thread_empty metrics_all_one_thread_empty.c $LIBS" "metrics.at:43"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o metrics_all_one_thread_empty metrics_all_one_thread_empty.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/metrics.at:43"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/metrics.at:43: ./metrics_all_one_thread_empty"
at_fn_check_prepare_trace "metrics.at:43"
( $at_check_trace; ./metrics_all_one_thread_empty
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/metrics.at:43"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_43
#AT_START_44
at_fn_group_banner 44 'metrics.at:62' \
  "metrics_all_both_threads_empty" "                 " 7
at_xfail=no
(
  $as_echo "44. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >metrics_all_both_threads_empty.c <<'_ATEOF'

#include <stdarg.h>
#include <lib/thread.h>
#include <lib/frame.h>
#include <lib/utils.h>
#include <stdlib.h>
#include <assert.h>
#include <lib/metrics.h>
#include <lib/normalize.h>

struct btp_thread *create_thread(int count, ...)
{
  struct btp_thread *thread = btp_thread_new();
  if (count == 0)
     return thread;
  int i;
  va_list argp;
  va_start(argp, count);

  for (i=0; i < count; i++)
  {
    const char *fname = va_arg(argp, const char*);
    struct btp_frame *frame = btp_frame_new();
    frame->function_name = btp_strdup(fname);

    if (thread->frames == NULL)thread->frames = frame;
    else btp_frame_add_sibling(thread->frames, frame);
  }

  va_end(argp);
  return thread;
}

bool is_dist_equal(float x, float y)
{
  float epsilon = 1e-6;
  return x - epsilon <= y && x + epsilon >= y;
}


int main()
{
  struct btp_thread *thread1 = create_thread(0);

  struct btp_thread *thread2 = create_thread(0);

  btp_normalize_paired_unknown_function_names(thread1, thread2);

  assert(is_dist_equal(1.0, btp_thread_jarowinkler_distance(thread1, thread2)));
  assert(is_dist_equal(0.0, btp_thread_jaccard_distance(thread1, thread2)));
  assert(0 == btp_thread_levenshtein_distance(thread1, thread2, false));
  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/metrics.at:62: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o metrics_all_both_threads_empty metrics_all_both_threads_empty.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o metrics_all_both_threads_empty metrics_all_both_threads_empty.c $LIBS" "metrics.at:62"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o metrics_all_both_threads_empty metrics_all_both_threads_empty.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/metrics.at:62"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/metrics.at:62: ./metrics_all_both_threads_empty"
at_fn_check_prepare_trace "metrics.at:62"
( $at_check_trace; ./metrics_all_both_threads_empty
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/metrics.at:62"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_44
#AT_START_45
at_fn_group_banner 45 'metrics.at:81' \
  "metrics_all_both_starting_??_levendistance3_a" "  " 7
at_xfail=no
(
  $as_echo "45. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >metrics_all_both_starting_??_levendistance3_a.c <<'_ATEOF'

#include <stdarg.h>
#include <lib/thread.h>
#include <lib/frame.h>
#include <lib/utils.h>
#include <stdlib.h>
#include <assert.h>
#include <lib/metrics.h>
#include <lib/normalize.h>

struct btp_thread *create_thread(int count, ...)
{
  struct btp_thread *thread = btp_thread_new();
  if (count == 0)
     return thread;
  int i;
  va_list argp;
  va_start(argp, count);

  for (i=0; i < count; i++)
  {
    const char *fname = va_arg(argp, const char*);
    struct btp_frame *frame = btp_frame_new();
    frame->function_name = btp_strdup(fname);

    if (thread->frames == NULL)thread->frames = frame;
    else btp_frame_add_sibling(thread->frames, frame);
  }

  va_end(argp);
  return thread;
}

bool is_dist_equal(float x, float y)
{
  float epsilon = 1e-6;
  return x - epsilon <= y && x + epsilon >= y;
}


int main()
{
  struct btp_thread *thread1 = create_thread(2, "??", "sd");

  struct btp_thread *thread2 = create_thread(3, "??", "ds", "main");

  btp_normalize_paired_unknown_function_names(thread1, thread2);

  assert(is_dist_equal(0.0, btp_thread_jarowinkler_distance(thread1, thread2)));
  assert(is_dist_equal(1.0, btp_thread_jaccard_distance(thread1, thread2)));
  assert(3 == btp_thread_levenshtein_distance(thread1, thread2, false));
  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/metrics.at:81: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o metrics_all_both_starting_??_levendistance3_a metrics_all_both_starting_??_levendistance3_a.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o metrics_all_both_starting_??_levendistance3_a metrics_all_both_starting_??_levendistance3_a.c $LIBS" "metrics.at:81"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o metrics_all_both_starting_??_levendistance3_a metrics_all_both_starting_??_levendistance3_a.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/metrics.at:81"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/metrics.at:81: ./metrics_all_both_starting_??_levendistance3_a"
at_fn_check_prepare_trace "metrics.at:81"
( $at_check_trace; ./metrics_all_both_starting_??_levendistance3_a
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/metrics.at:81"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_45
#AT_START_46
at_fn_group_banner 46 'metrics.at:100' \
  "metrics_all_both_starting_??_levendistance3_b" "  " 7
at_xfail=no
(
  $as_echo "46. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >metrics_all_both_starting_??_levendistance3_b.c <<'_ATEOF'

#include <stdarg.h>
#include <lib/thread.h>
#include <lib/frame.h>
#include <lib/utils.h>
#include <stdlib.h>
#include <assert.h>
#include <lib/metrics.h>
#include <lib/normalize.h>

struct btp_thread *create_thread(int count, ...)
{
  struct btp_thread *thread = btp_thread_new();
  if (count == 0)
     return thread;
  int i;
  va_list argp;
  va_start(argp, count);

  for (i=0; i < count; i++)
  {
    const char *fname = va_arg(argp, const char*);
    struct btp_frame *frame = btp_frame_new();
    frame->function_name = btp_strdup(fname);

    if (thread->frames == NULL)thread->frames = frame;
    else btp_frame_add_sibling(thread->frames, frame);
  }

  va_end(argp);
  return thread;
}

bool is_dist_equal(float x, float y)
{
  float epsilon = 1e-6;
  return x - epsilon <= y && x + epsilon >= y;
}


int main()
{
  struct btp_thread *thread1 = create_thread(1, "??");

  struct btp_thread *thread2 = create_thread(3, "??", "ds", "main");

  btp_normalize_paired_unknown_function_names(thread1, thread2);

  assert(is_dist_equal(0.0, btp_thread_jarowinkler_distance(thread1, thread2)));
  assert(is_dist_equal(1.0, btp_thread_jaccard_distance(thread1, thread2)));
  assert(3 == btp_thread_levenshtein_distance(thread1, thread2, false));
  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/metrics.at:100: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o metrics_all_both_starting_??_levendistance3_b metrics_all_both_starting_??_levendistance3_b.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o metrics_all_both_starting_??_levendistance3_b metrics_all_both_starting_??_levendistance3_b.c $LIBS" "metrics.at:100"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o metrics_all_both_starting_??_levendistance3_b metrics_all_both_starting_??_levendistance3_b.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/metrics.at:100"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/metrics.at:100: ./metrics_all_both_starting_??_levendistance3_b"
at_fn_check_prepare_trace "metrics.at:100"
( $at_check_trace; ./metrics_all_both_starting_??_levendistance3_b
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/metrics.at:100"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_46
#AT_START_47
at_fn_group_banner 47 'metrics.at:119' \
  "metrics_levenshtein_random_??_levendistance0_a" " " 7
at_xfail=no
(
  $as_echo "47. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >metrics_levenshtein_random_??_levendistance0_a.c <<'_ATEOF'

#include <stdarg.h>
#include <lib/thread.h>
#include <lib/frame.h>
#include <lib/utils.h>
#include <stdlib.h>
#include <assert.h>
#include <lib/metrics.h>
#include <lib/normalize.h>

struct btp_thread *create_thread(int count, ...)
{
  struct btp_thread *thread = btp_thread_new();
  if (count == 0)
     return thread;
  int i;
  va_list argp;
  va_start(argp, count);

  for (i=0; i < count; i++)
  {
    const char *fname = va_arg(argp, const char*);
    struct btp_frame *frame = btp_frame_new();
    frame->function_name = btp_strdup(fname);

    if (thread->frames == NULL)thread->frames = frame;
    else btp_frame_add_sibling(thread->frames, frame);
  }

  va_end(argp);
  return thread;
}

bool is_dist_equal(float x, float y)
{
  float epsilon = 1e-6;
  return x - epsilon <= y && x + epsilon >= y;
}


int main()
{
  struct btp_thread *thread1 = create_thread(3, "??", "ds", "main");

  struct btp_thread *thread2 = create_thread(3, "??", "ds", "main");

  btp_normalize_paired_unknown_function_names(thread1, thread2);

  assert(0 == btp_thread_levenshtein_distance(thread1, thread2, false));
  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/metrics.at:119: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o metrics_levenshtein_random_??_levendistance0_a metrics_levenshtein_random_??_levendistance0_a.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o metrics_levenshtein_random_??_levendistance0_a metrics_levenshtein_random_??_levendistance0_a.c $LIBS" "metrics.at:119"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o metrics_levenshtein_random_??_levendistance0_a metrics_levenshtein_random_??_levendistance0_a.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/metrics.at:119"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/metrics.at:119: ./metrics_levenshtein_random_??_levendistance0_a"
at_fn_check_prepare_trace "metrics.at:119"
( $at_check_trace; ./metrics_levenshtein_random_??_levendistance0_a
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/metrics.at:119"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_47
#AT_START_48
at_fn_group_banner 48 'metrics.at:136' \
  "metrics_levenshtein_random_??_levendistance0_b" " " 7
at_xfail=no
(
  $as_echo "48. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >metrics_levenshtein_random_??_levendistance0_b.c <<'_ATEOF'

#include <stdarg.h>
#include <lib/thread.h>
#include <lib/frame.h>
#include <lib/utils.h>
#include <stdlib.h>
#include <assert.h>
#include <lib/metrics.h>
#include <lib/normalize.h>

struct btp_thread *create_thread(int count, ...)
{
  struct btp_thread *thread = btp_thread_new();
  if (count == 0)
     return thread;
  int i;
  va_list argp;
  va_start(argp, count);

  for (i=0; i < count; i++)
  {
    const char *fname = va_arg(argp, const char*);
    struct btp_frame *frame = btp_frame_new();
    frame->function_name = btp_strdup(fname);

    if (thread->frames == NULL)thread->frames = frame;
    else btp_frame_add_sibling(thread->frames, frame);
  }

  va_end(argp);
  return thread;
}

bool is_dist_equal(float x, float y)
{
  float epsilon = 1e-6;
  return x - epsilon <= y && x + epsilon >= y;
}


int main()
{
  struct btp_thread *thread1 = create_thread(4, "dg", "??", "ds", "main");

  struct btp_thread *thread2 = create_thread(4, "dg", "??", "ds", "main");

  btp_normalize_paired_unknown_function_names(thread1, thread2);

  assert(0 == btp_thread_levenshtein_distance(thread1, thread2, false));
  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/metrics.at:136: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o metrics_levenshtein_random_??_levendistance0_b metrics_levenshtein_random_??_levendistance0_b.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o metrics_levenshtein_random_??_levendistance0_b metrics_levenshtein_random_??_levendistance0_b.c $LIBS" "metrics.at:136"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o metrics_levenshtein_random_??_levendistance0_b metrics_levenshtein_random_??_levendistance0_b.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/metrics.at:136"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/metrics.at:136: ./metrics_levenshtein_random_??_levendistance0_b"
at_fn_check_prepare_trace "metrics.at:136"
( $at_check_trace; ./metrics_levenshtein_random_??_levendistance0_b
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/metrics.at:136"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_48
#AT_START_49
at_fn_group_banner 49 'metrics.at:153' \
  "metrics_levenshtein_random_??_distance1" "        " 7
at_xfail=no
(
  $as_echo "49. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >metrics_levenshtein_random_??_distance1.c <<'_ATEOF'

#include <stdarg.h>
#include <lib/thread.h>
#include <lib/frame.h>
#include <lib/utils.h>
#include <stdlib.h>
#include <assert.h>
#include <lib/metrics.h>
#include <lib/normalize.h>

struct btp_thread *create_thread(int count, ...)
{
  struct btp_thread *thread = btp_thread_new();
  if (count == 0)
     return thread;
  int i;
  va_list argp;
  va_start(argp, count);

  for (i=0; i < count; i++)
  {
    const char *fname = va_arg(argp, const char*);
    struct btp_frame *frame = btp_frame_new();
    frame->function_name = btp_strdup(fname);

    if (thread->frames == NULL)thread->frames = frame;
    else btp_frame_add_sibling(thread->frames, frame);
  }

  va_end(argp);
  return thread;
}

bool is_dist_equal(float x, float y)
{
  float epsilon = 1e-6;
  return x - epsilon <= y && x + epsilon >= y;
}


int main()
{
  struct btp_thread *thread1 = create_thread(3, "dg", "??", "ds");

  struct btp_thread *thread2 = create_thread(4, "dg", "??", "ds", "main");

  btp_normalize_paired_unknown_function_names(thread1, thread2);

  assert(1 == btp_thread_levenshtein_distance(thread1, thread2, false));
  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/metrics.at:153: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o metrics_levenshtein_random_??_distance1 metrics_levenshtein_random_??_distance1.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o metrics_levenshtein_random_??_distance1 metrics_levenshtein_random_??_distance1.c $LIBS" "metrics.at:153"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o metrics_levenshtein_random_??_distance1 metrics_levenshtein_random_??_distance1.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/metrics.at:153"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/metrics.at:153: ./metrics_levenshtein_random_??_distance1"
at_fn_check_prepare_trace "metrics.at:153"
( $at_check_trace; ./metrics_levenshtein_random_??_distance1
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/metrics.at:153"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_49
#AT_START_50
at_fn_group_banner 50 'metrics.at:170' \
  "metrics_levenshtein_random_??_distance2_a" "      " 7
at_xfail=no
(
  $as_echo "50. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >metrics_levenshtein_random_??_distance2_a.c <<'_ATEOF'

#include <stdarg.h>
#include <lib/thread.h>
#include <lib/frame.h>
#include <lib/utils.h>
#include <stdlib.h>
#include <assert.h>
#include <lib/metrics.h>
#include <lib/normalize.h>

struct btp_thread *create_thread(int count, ...)
{
  struct btp_thread *thread = btp_thread_new();
  if (count == 0)
     return thread;
  int i;
  va_list argp;
  va_start(argp, count);

  for (i=0; i < count; i++)
  {
    const char *fname = va_arg(argp, const char*);
    struct btp_frame *frame = btp_frame_new();
    frame->function_name = btp_strdup(fname);

    if (thread->frames == NULL)thread->frames = frame;
    else btp_frame_add_sibling(thread->frames, frame);
  }

  va_end(argp);
  return thread;
}

bool is_dist_equal(float x, float y)
{
  float epsilon = 1e-6;
  return x - epsilon <= y && x + epsilon >= y;
}


int main()
{
  struct btp_thread *thread1 = create_thread(2, "dg", "??");

  struct btp_thread *thread2 = create_thread(3, "dg", "??", "main");

  btp_normalize_paired_unknown_function_names(thread1, thread2);

  assert(2 == btp_thread_levenshtein_distance(thread1, thread2, false));
  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/metrics.at:170: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o metrics_levenshtein_random_??_distance2_a metrics_levenshtein_random_??_distance2_a.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o metrics_levenshtein_random_??_distance2_a metrics_levenshtein_random_??_distance2_a.c $LIBS" "metrics.at:170"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o metrics_levenshtein_random_??_distance2_a metrics_levenshtein_random_??_distance2_a.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/metrics.at:170"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/metrics.at:170: ./metrics_levenshtein_random_??_distance2_a"
at_fn_check_prepare_trace "metrics.at:170"
( $at_check_trace; ./metrics_levenshtein_random_??_distance2_a
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/metrics.at:170"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_50
#AT_START_51
at_fn_group_banner 51 'metrics.at:187' \
  "metrics_levenshtein_random_??_distance2_b" "      " 7
at_xfail=no
(
  $as_echo "51. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >metrics_levenshtein_random_??_distance2_b.c <<'_ATEOF'

#include <stdarg.h>
#include <lib/thread.h>
#include <lib/frame.h>
#include <lib/utils.h>
#include <stdlib.h>
#include <assert.h>
#include <lib/metrics.h>
#include <lib/normalize.h>

struct btp_thread *create_thread(int count, ...)
{
  struct btp_thread *thread = btp_thread_new();
  if (count == 0)
     return thread;
  int i;
  va_list argp;
  va_start(argp, count);

  for (i=0; i < count; i++)
  {
    const char *fname = va_arg(argp, const char*);
    struct btp_frame *frame = btp_frame_new();
    frame->function_name = btp_strdup(fname);

    if (thread->frames == NULL)thread->frames = frame;
    else btp_frame_add_sibling(thread->frames, frame);
  }

  va_end(argp);
  return thread;
}

bool is_dist_equal(float x, float y)
{
  float epsilon = 1e-6;
  return x - epsilon <= y && x + epsilon >= y;
}


int main()
{
  struct btp_thread *thread1 = create_thread(3, "dg", "??", "??");

  struct btp_thread *thread2 = create_thread(4, "dg", "??", "??", "main");

  btp_normalize_paired_unknown_function_names(thread1, thread2);

  assert(3 == btp_thread_levenshtein_distance(thread1, thread2, false));
  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/metrics.at:187: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o metrics_levenshtein_random_??_distance2_b metrics_levenshtein_random_??_distance2_b.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o metrics_levenshtein_random_??_distance2_b metrics_levenshtein_random_??_distance2_b.c $LIBS" "metrics.at:187"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o metrics_levenshtein_random_??_distance2_b metrics_levenshtein_random_??_distance2_b.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/metrics.at:187"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/metrics.at:187: ./metrics_levenshtein_random_??_distance2_b"
at_fn_check_prepare_trace "metrics.at:187"
( $at_check_trace; ./metrics_levenshtein_random_??_distance2_b
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/metrics.at:187"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_51
#AT_START_52
at_fn_group_banner 52 'metrics.at:204' \
  "metrics_levenshtein_random_??_distance2_c" "      " 7
at_xfail=no
(
  $as_echo "52. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >metrics_levenshtein_random_??_distance2_c.c <<'_ATEOF'

#include <stdarg.h>
#include <lib/thread.h>
#include <lib/frame.h>
#include <lib/utils.h>
#include <stdlib.h>
#include <assert.h>
#include <lib/metrics.h>
#include <lib/normalize.h>

struct btp_thread *create_thread(int count, ...)
{
  struct btp_thread *thread = btp_thread_new();
  if (count == 0)
     return thread;
  int i;
  va_list argp;
  va_start(argp, count);

  for (i=0; i < count; i++)
  {
    const char *fname = va_arg(argp, const char*);
    struct btp_frame *frame = btp_frame_new();
    frame->function_name = btp_strdup(fname);

    if (thread->frames == NULL)thread->frames = frame;
    else btp_frame_add_sibling(thread->frames, frame);
  }

  va_end(argp);
  return thread;
}

bool is_dist_equal(float x, float y)
{
  float epsilon = 1e-6;
  return x - epsilon <= y && x + epsilon >= y;
}


int main()
{
  struct btp_thread *thread1 = create_thread(3, "??", "??", "main");

  struct btp_thread *thread2 = create_thread(2, "??", "??");

  btp_normalize_paired_unknown_function_names(thread1, thread2);

  assert(3 == btp_thread_levenshtein_distance(thread1, thread2, false));
  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/metrics.at:204: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o metrics_levenshtein_random_??_distance2_c metrics_levenshtein_random_??_distance2_c.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o metrics_levenshtein_random_??_distance2_c metrics_levenshtein_random_??_distance2_c.c $LIBS" "metrics.at:204"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o metrics_levenshtein_random_??_distance2_c metrics_levenshtein_random_??_distance2_c.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/metrics.at:204"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/metrics.at:204: ./metrics_levenshtein_random_??_distance2_c"
at_fn_check_prepare_trace "metrics.at:204"
( $at_check_trace; ./metrics_levenshtein_random_??_distance2_c
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/metrics.at:204"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_52
#AT_START_53
at_fn_group_banner 53 'metrics.at:221' \
  "metrics_levenshtein_trans_??_distance2_a" "       " 7
at_xfail=no
(
  $as_echo "53. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >metrics_levenshtein_trans_??_distance2_a.c <<'_ATEOF'

#include <stdarg.h>
#include <lib/thread.h>
#include <lib/frame.h>
#include <lib/utils.h>
#include <stdlib.h>
#include <assert.h>
#include <lib/metrics.h>
#include <lib/normalize.h>

struct btp_thread *create_thread(int count, ...)
{
  struct btp_thread *thread = btp_thread_new();
  if (count == 0)
     return thread;
  int i;
  va_list argp;
  va_start(argp, count);

  for (i=0; i < count; i++)
  {
    const char *fname = va_arg(argp, const char*);
    struct btp_frame *frame = btp_frame_new();
    frame->function_name = btp_strdup(fname);

    if (thread->frames == NULL)thread->frames = frame;
    else btp_frame_add_sibling(thread->frames, frame);
  }

  va_end(argp);
  return thread;
}

bool is_dist_equal(float x, float y)
{
  float epsilon = 1e-6;
  return x - epsilon <= y && x + epsilon >= y;
}


int main()
{
  struct btp_thread *thread1 = create_thread(5, "ale", "asd", "??", "agd", "dsa");

  struct btp_thread *thread2 = create_thread(5, "ale", "huga", "asd", "??", "agd");

  btp_normalize_paired_unknown_function_names(thread1, thread2);

  assert(2 == btp_thread_levenshtein_distance(thread1, thread2, true));
  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/metrics.at:221: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o metrics_levenshtein_trans_??_distance2_a metrics_levenshtein_trans_??_distance2_a.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o metrics_levenshtein_trans_??_distance2_a metrics_levenshtein_trans_??_distance2_a.c $LIBS" "metrics.at:221"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o metrics_levenshtein_trans_??_distance2_a metrics_levenshtein_trans_??_distance2_a.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/metrics.at:221"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/metrics.at:221: ./metrics_levenshtein_trans_??_distance2_a"
at_fn_check_prepare_trace "metrics.at:221"
( $at_check_trace; ./metrics_levenshtein_trans_??_distance2_a
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/metrics.at:221"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_53
#AT_START_54
at_fn_group_banner 54 'metrics.at:238' \
  "metrics_levenshtein_trans_??_distance2_b" "       " 7
at_xfail=no
(
  $as_echo "54. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >metrics_levenshtein_trans_??_distance2_b.c <<'_ATEOF'

#include <stdarg.h>
#include <lib/thread.h>
#include <lib/frame.h>
#include <lib/utils.h>
#include <stdlib.h>
#include <assert.h>
#include <lib/metrics.h>
#include <lib/normalize.h>

struct btp_thread *create_thread(int count, ...)
{
  struct btp_thread *thread = btp_thread_new();
  if (count == 0)
     return thread;
  int i;
  va_list argp;
  va_start(argp, count);

  for (i=0; i < count; i++)
  {
    const char *fname = va_arg(argp, const char*);
    struct btp_frame *frame = btp_frame_new();
    frame->function_name = btp_strdup(fname);

    if (thread->frames == NULL)thread->frames = frame;
    else btp_frame_add_sibling(thread->frames, frame);
  }

  va_end(argp);
  return thread;
}

bool is_dist_equal(float x, float y)
{
  float epsilon = 1e-6;
  return x - epsilon <= y && x + epsilon >= y;
}


int main()
{
  struct btp_thread *thread1 = create_thread(4, "asd", "??", "agd", "dsa");

  struct btp_thread *thread2 = create_thread(4, "asd", "agd", "??", "dsa");

  btp_normalize_paired_unknown_function_names(thread1, thread2);

  assert(2 == btp_thread_levenshtein_distance(thread1, thread2, true));
  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/metrics.at:238: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o metrics_levenshtein_trans_??_distance2_b metrics_levenshtein_trans_??_distance2_b.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o metrics_levenshtein_trans_??_distance2_b metrics_levenshtein_trans_??_distance2_b.c $LIBS" "metrics.at:238"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o metrics_levenshtein_trans_??_distance2_b metrics_levenshtein_trans_??_distance2_b.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/metrics.at:238"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/metrics.at:238: ./metrics_levenshtein_trans_??_distance2_b"
at_fn_check_prepare_trace "metrics.at:238"
( $at_check_trace; ./metrics_levenshtein_trans_??_distance2_b
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/metrics.at:238"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_54
#AT_START_55
at_fn_group_banner 55 'metrics.at:255' \
  "metrics_levenshtein_swap_trans_distance2_a" "     " 7
at_xfail=no
(
  $as_echo "55. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >metrics_levenshtein_swap_trans_distance2_a.c <<'_ATEOF'

#include <stdarg.h>
#include <lib/thread.h>
#include <lib/frame.h>
#include <lib/utils.h>
#include <stdlib.h>
#include <assert.h>
#include <lib/metrics.h>
#include <lib/normalize.h>

struct btp_thread *create_thread(int count, ...)
{
  struct btp_thread *thread = btp_thread_new();
  if (count == 0)
     return thread;
  int i;
  va_list argp;
  va_start(argp, count);

  for (i=0; i < count; i++)
  {
    const char *fname = va_arg(argp, const char*);
    struct btp_frame *frame = btp_frame_new();
    frame->function_name = btp_strdup(fname);

    if (thread->frames == NULL)thread->frames = frame;
    else btp_frame_add_sibling(thread->frames, frame);
  }

  va_end(argp);
  return thread;
}

bool is_dist_equal(float x, float y)
{
  float epsilon = 1e-6;
  return x - epsilon <= y && x + epsilon >= y;
}


int main()
{
  struct btp_thread *thread1 = create_thread(4, "a", "b", "c", "d");
  struct btp_thread *thread2 = create_thread(4, "b", "a", "d", "c");

  assert(2 == btp_thread_levenshtein_distance(thread1, thread2, true));
  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/metrics.at:255: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o metrics_levenshtein_swap_trans_distance2_a metrics_levenshtein_swap_trans_distance2_a.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o metrics_levenshtein_swap_trans_distance2_a metrics_levenshtein_swap_trans_distance2_a.c $LIBS" "metrics.at:255"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o metrics_levenshtein_swap_trans_distance2_a metrics_levenshtein_swap_trans_distance2_a.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/metrics.at:255"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/metrics.at:255: ./metrics_levenshtein_swap_trans_distance2_a"
at_fn_check_prepare_trace "metrics.at:255"
( $at_check_trace; ./metrics_levenshtein_swap_trans_distance2_a
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/metrics.at:255"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_55
#AT_START_56
at_fn_group_banner 56 'metrics.at:269' \
  "metrics_levenshtein_swap_notrans_distance3_a" "   " 7
at_xfail=no
(
  $as_echo "56. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >metrics_levenshtein_swap_notrans_distance3_a.c <<'_ATEOF'

#include <stdarg.h>
#include <lib/thread.h>
#include <lib/frame.h>
#include <lib/utils.h>
#include <stdlib.h>
#include <assert.h>
#include <lib/metrics.h>
#include <lib/normalize.h>

struct btp_thread *create_thread(int count, ...)
{
  struct btp_thread *thread = btp_thread_new();
  if (count == 0)
     return thread;
  int i;
  va_list argp;
  va_start(argp, count);

  for (i=0; i < count; i++)
  {
    const char *fname = va_arg(argp, const char*);
    struct btp_frame *frame = btp_frame_new();
    frame->function_name = btp_strdup(fname);

    if (thread->frames == NULL)thread->frames = frame;
    else btp_frame_add_sibling(thread->frames, frame);
  }

  va_end(argp);
  return thread;
}

bool is_dist_equal(float x, float y)
{
  float epsilon = 1e-6;
  return x - epsilon <= y && x + epsilon >= y;
}


int main()
{
  struct btp_thread *thread1 = create_thread(4, "a", "b", "c", "d");
  struct btp_thread *thread2 = create_thread(4, "b", "a", "d", "c");

  assert(3 == btp_thread_levenshtein_distance(thread1, thread2, false));
  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/metrics.at:269: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o metrics_levenshtein_swap_notrans_distance3_a metrics_levenshtein_swap_notrans_distance3_a.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o metrics_levenshtein_swap_notrans_distance3_a metrics_levenshtein_swap_notrans_distance3_a.c $LIBS" "metrics.at:269"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o metrics_levenshtein_swap_notrans_distance3_a metrics_levenshtein_swap_notrans_distance3_a.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/metrics.at:269"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/metrics.at:269: ./metrics_levenshtein_swap_notrans_distance3_a"
at_fn_check_prepare_trace "metrics.at:269"
( $at_check_trace; ./metrics_levenshtein_swap_notrans_distance3_a
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/metrics.at:269"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_56
#AT_START_57
at_fn_group_banner 57 'metrics.at:283' \
  "metrics_jaccard_random_??_distance0_a" "          " 7
at_xfail=no
(
  $as_echo "57. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >metrics_jaccard_random_??_distance0_a.c <<'_ATEOF'

#include <stdarg.h>
#include <lib/thread.h>
#include <lib/frame.h>
#include <lib/utils.h>
#include <stdlib.h>
#include <assert.h>
#include <lib/metrics.h>
#include <lib/normalize.h>

struct btp_thread *create_thread(int count, ...)
{
  struct btp_thread *thread = btp_thread_new();
  if (count == 0)
     return thread;
  int i;
  va_list argp;
  va_start(argp, count);

  for (i=0; i < count; i++)
  {
    const char *fname = va_arg(argp, const char*);
    struct btp_frame *frame = btp_frame_new();
    frame->function_name = btp_strdup(fname);

    if (thread->frames == NULL)thread->frames = frame;
    else btp_frame_add_sibling(thread->frames, frame);
  }

  va_end(argp);
  return thread;
}

bool is_dist_equal(float x, float y)
{
  float epsilon = 1e-6;
  return x - epsilon <= y && x + epsilon >= y;
}


int main()
{
  struct btp_thread *thread1 = create_thread(4, "asd", "agd", "agd", "??");

  struct btp_thread *thread2 = create_thread(3, "asd", "agd", "??");

  btp_normalize_paired_unknown_function_names(thread1, thread2);

  assert(is_dist_equal(0.0, btp_thread_jaccard_distance(thread1, thread2)));
  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/metrics.at:283: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o metrics_jaccard_random_??_distance0_a metrics_jaccard_random_??_distance0_a.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o metrics_jaccard_random_??_distance0_a metrics_jaccard_random_??_distance0_a.c $LIBS" "metrics.at:283"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o metrics_jaccard_random_??_distance0_a metrics_jaccard_random_??_distance0_a.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/metrics.at:283"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/metrics.at:283: ./metrics_jaccard_random_??_distance0_a"
at_fn_check_prepare_trace "metrics.at:283"
( $at_check_trace; ./metrics_jaccard_random_??_distance0_a
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/metrics.at:283"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_57
#AT_START_58
at_fn_group_banner 58 'metrics.at:300' \
  "metrics_jaccard_random_??_distance23_a" "         " 7
at_xfail=no
(
  $as_echo "58. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >metrics_jaccard_random_??_distance23_a.c <<'_ATEOF'

#include <stdarg.h>
#include <lib/thread.h>
#include <lib/frame.h>
#include <lib/utils.h>
#include <stdlib.h>
#include <assert.h>
#include <lib/metrics.h>
#include <lib/normalize.h>

struct btp_thread *create_thread(int count, ...)
{
  struct btp_thread *thread = btp_thread_new();
  if (count == 0)
     return thread;
  int i;
  va_list argp;
  va_start(argp, count);

  for (i=0; i < count; i++)
  {
    const char *fname = va_arg(argp, const char*);
    struct btp_frame *frame = btp_frame_new();
    frame->function_name = btp_strdup(fname);

    if (thread->frames == NULL)thread->frames = frame;
    else btp_frame_add_sibling(thread->frames, frame);
  }

  va_end(argp);
  return thread;
}

bool is_dist_equal(float x, float y)
{
  float epsilon = 1e-6;
  return x - epsilon <= y && x + epsilon >= y;
}


int main()
{
  struct btp_thread *thread1 = create_thread(3, "asd", "agd", "agd");

  struct btp_thread *thread2 = create_thread(2, "sad", "agd");

  assert(is_dist_equal(2/3.0, btp_thread_jaccard_distance(thread1, thread2)));
  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/metrics.at:300: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o metrics_jaccard_random_??_distance23_a metrics_jaccard_random_??_distance23_a.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o metrics_jaccard_random_??_distance23_a metrics_jaccard_random_??_distance23_a.c $LIBS" "metrics.at:300"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o metrics_jaccard_random_??_distance23_a metrics_jaccard_random_??_distance23_a.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/metrics.at:300"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/metrics.at:300: ./metrics_jaccard_random_??_distance23_a"
at_fn_check_prepare_trace "metrics.at:300"
( $at_check_trace; ./metrics_jaccard_random_??_distance23_a
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/metrics.at:300"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_58
#AT_START_59
at_fn_group_banner 59 'metrics.at:315' \
  "metrics_jaccard_random_??_distance35" "           " 7
at_xfail=no
(
  $as_echo "59. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >metrics_jaccard_random_??_distance35.c <<'_ATEOF'

#include <stdarg.h>
#include <lib/thread.h>
#include <lib/frame.h>
#include <lib/utils.h>
#include <stdlib.h>
#include <assert.h>
#include <lib/metrics.h>
#include <lib/normalize.h>

struct btp_thread *create_thread(int count, ...)
{
  struct btp_thread *thread = btp_thread_new();
  if (count == 0)
     return thread;
  int i;
  va_list argp;
  va_start(argp, count);

  for (i=0; i < count; i++)
  {
    const char *fname = va_arg(argp, const char*);
    struct btp_frame *frame = btp_frame_new();
    frame->function_name = btp_strdup(fname);

    if (thread->frames == NULL)thread->frames = frame;
    else btp_frame_add_sibling(thread->frames, frame);
  }

  va_end(argp);
  return thread;
}

bool is_dist_equal(float x, float y)
{
  float epsilon = 1e-6;
  return x - epsilon <= y && x + epsilon >= y;
}


int main()
{
  struct btp_thread *thread1 = create_thread(5, "asd", "agd", "gad", "sad", "abc");

  struct btp_thread *thread2 = create_thread(4, "sad", "sad", "sad", "gad");

  assert(is_dist_equal(3/5.0, btp_thread_jaccard_distance(thread1, thread2)));
  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/metrics.at:315: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o metrics_jaccard_random_??_distance35 metrics_jaccard_random_??_distance35.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o metrics_jaccard_random_??_distance35 metrics_jaccard_random_??_distance35.c $LIBS" "metrics.at:315"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o metrics_jaccard_random_??_distance35 metrics_jaccard_random_??_distance35.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/metrics.at:315"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/metrics.at:315: ./metrics_jaccard_random_??_distance35"
at_fn_check_prepare_trace "metrics.at:315"
( $at_check_trace; ./metrics_jaccard_random_??_distance35
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/metrics.at:315"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_59
#AT_START_60
at_fn_group_banner 60 'metrics.at:330' \
  "distances_basic_properties" "                     " 7
at_xfail=no
(
  $as_echo "60. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >distances_basic_properties.c <<'_ATEOF'

#include <stdarg.h>
#include <lib/thread.h>
#include <lib/frame.h>
#include <lib/utils.h>
#include <stdlib.h>
#include <assert.h>
#include <lib/metrics.h>
#include <lib/normalize.h>

struct btp_thread *create_thread(int count, ...)
{
  struct btp_thread *thread = btp_thread_new();
  if (count == 0)
     return thread;
  int i;
  va_list argp;
  va_start(argp, count);

  for (i=0; i < count; i++)
  {
    const char *fname = va_arg(argp, const char*);
    struct btp_frame *frame = btp_frame_new();
    frame->function_name = btp_strdup(fname);

    if (thread->frames == NULL)thread->frames = frame;
    else btp_frame_add_sibling(thread->frames, frame);
  }

  va_end(argp);
  return thread;
}

bool is_dist_equal(float x, float y)
{
  float epsilon = 1e-6;
  return x - epsilon <= y && x + epsilon >= y;
}


int main()
{
  int m = 50, n = 100, i, j;
  struct btp_distances *distances = btp_distances_new(m, n);
  float x;

  for (i = 0; i < m; i++)
    for (j = 0; j < n; j++)
      btp_distances_set_distance(distances, i, j, i + j / 1000.0);

  for (i = 0; i < m; i++)
    for (j = 0; j < n; j++)
    {
      x = btp_distances_get_distance(distances, i, j);
      if (i == j)
         assert(x == 0.0);
      else if (j < m && i < j)
         assert(is_dist_equal(j + i / 1000.0, x));
      else
         assert(is_dist_equal(i + j / 1000.0, x));
    }

  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/metrics.at:330: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o distances_basic_properties distances_basic_properties.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o distances_basic_properties distances_basic_properties.c $LIBS" "metrics.at:330"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o distances_basic_properties distances_basic_properties.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/metrics.at:330"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/metrics.at:330: ./distances_basic_properties"
at_fn_check_prepare_trace "metrics.at:330"
( $at_check_trace; ./distances_basic_properties
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/metrics.at:330"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_60
#AT_START_61
at_fn_group_banner 61 'metrics.at:360' \
  "distances_threads_compare" "                      " 7
at_xfail=no
(
  $as_echo "61. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >distances_threads_compare.c <<'_ATEOF'

#include <stdarg.h>
#include <lib/thread.h>
#include <lib/frame.h>
#include <lib/utils.h>
#include <stdlib.h>
#include <assert.h>
#include <lib/metrics.h>
#include <lib/normalize.h>

struct btp_thread *create_thread(int count, ...)
{
  struct btp_thread *thread = btp_thread_new();
  if (count == 0)
     return thread;
  int i;
  va_list argp;
  va_start(argp, count);

  for (i=0; i < count; i++)
  {
    const char *fname = va_arg(argp, const char*);
    struct btp_frame *frame = btp_frame_new();
    frame->function_name = btp_strdup(fname);

    if (thread->frames == NULL)thread->frames = frame;
    else btp_frame_add_sibling(thread->frames, frame);
  }

  va_end(argp);
  return thread;
}

bool is_dist_equal(float x, float y)
{
  float epsilon = 1e-6;
  return x - epsilon <= y && x + epsilon >= y;
}


int main()
{
  struct btp_thread *threads[4];
  threads[0] = create_thread(4, "asd", "agd", "das", "??");
  threads[1] = create_thread(3, "asd", "agd", "??");
  threads[2] = create_thread(3, "asd", "agd", "??");
  threads[3] = create_thread(3, "dg", "??", "??");

  struct btp_distances *distances = btp_threads_compare(threads, 3, 4, btp_thread_jaccard_distance);
  assert(is_dist_equal(0.6, btp_distances_get_distance(distances, 0, 1)));
  assert(is_dist_equal(0.6, btp_distances_get_distance(distances, 0, 2)));
  assert(is_dist_equal(1.0, btp_distances_get_distance(distances, 0, 3)));
  assert(is_dist_equal(0.0, btp_distances_get_distance(distances, 1, 2)));
  assert(is_dist_equal(1.0, btp_distances_get_distance(distances, 1, 3)));
  assert(is_dist_equal(1.0, btp_distances_get_distance(distances, 2, 3)));

  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/metrics.at:360: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o distances_threads_compare distances_threads_compare.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o distances_threads_compare distances_threads_compare.c $LIBS" "metrics.at:360"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o distances_threads_compare distances_threads_compare.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/metrics.at:360"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/metrics.at:360: ./distances_threads_compare"
at_fn_check_prepare_trace "metrics.at:360"
( $at_check_trace; ./distances_threads_compare
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/metrics.at:360"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_61
#AT_START_62
at_fn_group_banner 62 'cluster.at:3' \
  "btp_distances_cluster_objects" "                  " 8
at_xfail=no
(
  $as_echo "62. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >btp_distances_cluster_objects.c <<'_ATEOF'

#include <lib/metrics.h>
#include <lib/cluster.h>
#include <assert.h>

#include <stdio.h>

bool is_dist_equal(float x, float y)
{
  float epsilon = 1e-6;
  return x - epsilon <= y && x + epsilon >= y;
}

int main()
{
  struct btp_distances *distances;
  struct btp_dendrogram *dendrogram;

  distances = btp_distances_new(3, 4);
  btp_distances_set_distance(distances, 0, 1, 1.0);
  btp_distances_set_distance(distances, 0, 2, 0.5);
  btp_distances_set_distance(distances, 0, 3, 0.0);
  btp_distances_set_distance(distances, 1, 2, 0.1);
  btp_distances_set_distance(distances, 1, 3, 0.3);
  btp_distances_set_distance(distances, 2, 3, 0.7);

  dendrogram = btp_distances_cluster_objects(distances);

  assert(dendrogram->size == 4);

  assert(dendrogram->order[0] == 0);
  assert(dendrogram->order[1] == 3);
  assert(dendrogram->order[2] == 1);
  assert(dendrogram->order[3] == 2);

  assert(is_dist_equal(dendrogram->merge_levels[0], 0.0));
  assert(is_dist_equal(dendrogram->merge_levels[1], 0.625));
  assert(is_dist_equal(dendrogram->merge_levels[2], 0.1));

  distances = btp_distances_new(1, 6);
  btp_distances_set_distance(distances, 0, 1, 1.0);
  btp_distances_set_distance(distances, 0, 2, 0.5);
  btp_distances_set_distance(distances, 0, 3, 0.3);
  btp_distances_set_distance(distances, 0, 4, 0.0);
  btp_distances_set_distance(distances, 0, 5, 0.9);

  dendrogram = btp_distances_cluster_objects(distances);

  assert(dendrogram->size == 6);

  assert(dendrogram->order[0] == 0);
  assert(dendrogram->order[1] == 4);
  assert(dendrogram->order[2] == 3);
  assert(dendrogram->order[3] == 2);
  assert(dendrogram->order[4] == 5);
  assert(dendrogram->order[5] == 1);

  assert(is_dist_equal(dendrogram->merge_levels[0], 0.0));
  assert(is_dist_equal(dendrogram->merge_levels[1], 0.3));
  assert(is_dist_equal(dendrogram->merge_levels[2], 0.5));
  assert(is_dist_equal(dendrogram->merge_levels[3], 0.9));
  assert(is_dist_equal(dendrogram->merge_levels[4], 1.0));

  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/cluster.at:3: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o btp_distances_cluster_objects btp_distances_cluster_objects.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o btp_distances_cluster_objects btp_distances_cluster_objects.c $LIBS" "cluster.at:3"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o btp_distances_cluster_objects btp_distances_cluster_objects.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/cluster.at:3"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/cluster.at:3: ./btp_distances_cluster_objects"
at_fn_check_prepare_trace "cluster.at:3"
( $at_check_trace; ./btp_distances_cluster_objects
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/cluster.at:3"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_62
#AT_START_63
at_fn_group_banner 63 'cluster.at:71' \
  "btp_dendrogram_cut" "                             " 8
at_xfail=no
(
  $as_echo "63. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >btp_dendrogram_cut.c <<'_ATEOF'

#include <lib/metrics.h>
#include <lib/cluster.h>
#include <assert.h>

#include <stdio.h>

int main()
{
  struct btp_dendrogram *dendrogram;
  struct btp_cluster *cluster;

  dendrogram = btp_dendrogram_new(6);

  dendrogram->order[0] = 0;
  dendrogram->order[1] = 3;
  dendrogram->order[2] = 1;
  dendrogram->order[3] = 2;
  dendrogram->order[4] = 4;
  dendrogram->order[5] = 5;

  dendrogram->merge_levels[0] = 0.0;
  dendrogram->merge_levels[1] = 0.6;
  dendrogram->merge_levels[2] = 0.1;
  dendrogram->merge_levels[3] = 0.5;
  dendrogram->merge_levels[4] = 0.3;

  cluster = btp_dendrogram_cut(dendrogram, 0.2, 1);

  assert(cluster);

  assert(cluster->size == 1);
  assert(cluster->objects[0] == 5);
  assert(cluster->next);
  cluster = cluster->next;

  assert(cluster->size == 1);
  assert(cluster->objects[0] == 4);
  assert(cluster->next);
  cluster = cluster->next;

  assert(cluster->size == 2);
  assert(cluster->objects[0] == 1);
  assert(cluster->objects[1] == 2);
  assert(cluster->next);
  cluster = cluster->next;

  assert(cluster->size == 2);
  assert(cluster->objects[0] == 0);
  assert(cluster->objects[1] == 3);

  assert(!cluster->next);

  cluster = btp_dendrogram_cut(dendrogram, 0.5, 3);

  assert(cluster);

  assert(cluster->size == 4);
  assert(cluster->objects[0] == 1);
  assert(cluster->objects[1] == 2);
  assert(cluster->objects[2] == 4);
  assert(cluster->objects[3] == 5);

  assert(!cluster->next);

  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/cluster.at:71: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o btp_dendrogram_cut btp_dendrogram_cut.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o btp_dendrogram_cut btp_dendrogram_cut.c $LIBS" "cluster.at:71"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o btp_dendrogram_cut btp_dendrogram_cut.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/cluster.at:71"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/cluster.at:71: ./btp_dendrogram_cut"
at_fn_check_prepare_trace "cluster.at:71"
( $at_check_trace; ./btp_dendrogram_cut
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/cluster.at:71"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_63
#AT_START_64
at_fn_group_banner 64 'sharedlib.at:8' \
  "btp_sharedlib_parse" "                            " 9
at_xfail=no
(
  $as_echo "64. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >btp_sharedlib_parse.c <<'_ATEOF'

#include <lib/sharedlib.h>
#include <lib/utils.h>
#include <assert.h>
#include <stdlib.h>

int main(void)
{
  char *bt = btp_file_to_string("../../backtraces/621492.bt");
  assert(bt);
  struct btp_sharedlib *libs = btp_sharedlib_parse(bt);
  assert(libs);
  assert(libs->from == 0x0000003848c05640);
  assert(libs->to == 0x0000003848c10e48);
  assert(libs->symbols == SYMS_OK);
  assert(strcmp("/lib64/libpthread.so.0", libs->soname) == 0);
  btp_sharedlib_free(libs);
  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/sharedlib.at:8: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o btp_sharedlib_parse btp_sharedlib_parse.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o btp_sharedlib_parse btp_sharedlib_parse.c $LIBS" "sharedlib.at:8"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o btp_sharedlib_parse btp_sharedlib_parse.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/sharedlib.at:8"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/sharedlib.at:8: ./btp_sharedlib_parse"
at_fn_check_prepare_trace "sharedlib.at:8"
( $at_check_trace; ./btp_sharedlib_parse
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/sharedlib.at:8"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_64
#AT_START_65
at_fn_group_banner 65 'sharedlib.at:33' \
  "btp_sharedlib_count" "                            " 9
at_xfail=no
(
  $as_echo "65. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >btp_sharedlib_count.c <<'_ATEOF'

#include <lib/sharedlib.h>
#include <lib/utils.h>
#include <assert.h>
#include <stdlib.h>

int main(void)
{
  char *bt = btp_file_to_string("../../backtraces/621492.bt");
  assert(bt);
  struct btp_sharedlib *libs = btp_sharedlib_parse(bt);
  assert(libs);
  assert(btp_sharedlib_count(libs) == 185);
  btp_sharedlib_free(libs);
  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/sharedlib.at:33: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o btp_sharedlib_count btp_sharedlib_count.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o btp_sharedlib_count btp_sharedlib_count.c $LIBS" "sharedlib.at:33"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o btp_sharedlib_count btp_sharedlib_count.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/sharedlib.at:33"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/sharedlib.at:33: ./btp_sharedlib_count"
at_fn_check_prepare_trace "sharedlib.at:33"
( $at_check_trace; ./btp_sharedlib_count
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/sharedlib.at:33"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_65
#AT_START_66
at_fn_group_banner 66 'sharedlib.at:55' \
  "btp_sharedlib_append" "                           " 9
at_xfail=no
(
  $as_echo "66. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >btp_sharedlib_append.c <<'_ATEOF'

#include <lib/sharedlib.h>
#include <assert.h>
#include <stdlib.h>

int main(void)
{
  struct btp_sharedlib *lib1 = btp_sharedlib_new();
  assert(lib1);
  struct btp_sharedlib *lib2 = btp_sharedlib_new();
  assert(lib2);
  assert(btp_sharedlib_count(lib1) == 1);
  assert(btp_sharedlib_count(lib2) == 1);
  btp_sharedlib_append(lib1, lib2);
  assert(btp_sharedlib_count(lib1) == 2);
  assert(btp_sharedlib_count(lib2) == 1);
  btp_sharedlib_free(lib1);
  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/sharedlib.at:55: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o btp_sharedlib_append btp_sharedlib_append.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o btp_sharedlib_append btp_sharedlib_append.c $LIBS" "sharedlib.at:55"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o btp_sharedlib_append btp_sharedlib_append.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/sharedlib.at:55"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/sharedlib.at:55: ./btp_sharedlib_append"
at_fn_check_prepare_trace "sharedlib.at:55"
( $at_check_trace; ./btp_sharedlib_append
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/sharedlib.at:55"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_66
#AT_START_67
at_fn_group_banner 67 'sharedlib.at:80' \
  "btp_sharedlib_find_address" "                     " 9
at_xfail=no
(
  $as_echo "67. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >btp_sharedlib_find_address.c <<'_ATEOF'

#include <lib/sharedlib.h>
#include <lib/utils.h>
#include <assert.h>
#include <stdlib.h>

int main(void)
{
  char *bt = btp_file_to_string("../../backtraces/621492.bt");
  assert(bt);
  struct btp_sharedlib *libs = btp_sharedlib_parse(bt);
  assert(libs);
  assert(btp_sharedlib_find_address(libs, 0x0000003848c08000));
  assert(btp_sharedlib_find_address(libs, 0x00007f907d3f0000));
  assert(!btp_sharedlib_find_address(libs, 0));
  assert(!btp_sharedlib_find_address(libs, 0xffff00000000ffff));
  btp_sharedlib_free(libs);
  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/sharedlib.at:80: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o btp_sharedlib_find_address btp_sharedlib_find_address.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o btp_sharedlib_find_address btp_sharedlib_find_address.c $LIBS" "sharedlib.at:80"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o btp_sharedlib_find_address btp_sharedlib_find_address.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/sharedlib.at:80"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/sharedlib.at:80: ./btp_sharedlib_find_address"
at_fn_check_prepare_trace "sharedlib.at:80"
( $at_check_trace; ./btp_sharedlib_find_address
) >>"$at_stdout" 2>>"$at_stderr"
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/sharedlib.at:80"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_67
